# Spring Bootオンライン処理スケルトン設計書 (AP基盤)

## 1. 設計方針
- 共通機能をベースクラスとして実装し、業務毎の機能はこれを継承して実装する
- 依存性注入(DI)を活用した疎結合な設計
- レイヤードアーキテクチャを採用
- RESTful APIを基本とする

## 2. プロジェクト構成

```
src/main/java/com/example/apbase/
├── common/               # 共通機能パッケージ
│   ├── config/           # 設定関連
│   ├── exception/        # 例外処理
│   ├── filter/           # フィルター
│   ├── interceptor/      # インターセプター
│   ├── logging/          # ロギング
│   ├── model/            # 共通モデル
│   ├── util/             # ユーティリティ
│   └── validation/       # バリデーション
├── controller/           # コントローラーベース
├── service/              # サービスベース
├── repository/           # リポジトリベース
└── entity/               # エンティティベース
```

## 3. 共通ベースクラス設計

### 3.1 ベースコントローラー (`BaseController`)

```java
package com.example.apbase.controller;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

public abstract class BaseController<T, ID> {

    /**
     * エンティティ作成
     * @param entity 作成対象エンティティ
     * @return 作成済みエンティティ
     */
    @PostMapping
    public abstract ResponseEntity<T> create(@RequestBody T entity);

    /**
     * エンティティ取得
     * @param id エンティティID
     * @return 取得したエンティティ
     */
    @GetMapping("/{id}")
    public abstract ResponseEntity<T> read(@PathVariable ID id);

    /**
     * エンティティ更新
     * @param id 更新対象エンティティID
     * @param entity 更新内容
     * @return 更新済みエンティティ
     */
    @PutMapping("/{id}")
    public abstract ResponseEntity<T> update(@PathVariable ID id, @RequestBody T entity);

    /**
     * エンティティ削除
     * @param id 削除対象エンティティID
     * @return 処理結果
     */
    @DeleteMapping("/{id}")
    public abstract ResponseEntity<Void> delete(@PathVariable ID id);
}
```

### 3.2 ベースサービス (`BaseService`)

```java
package com.example.apbase.service;

import java.util.List;

public interface BaseService<T, ID> {
    T create(T entity);
    T findById(ID id);
    List<T> findAll();
    T update(ID id, T entity);
    void delete(ID id);
}
```

### 3.3 ベースリポジトリ (`BaseRepository`)

```java
package com.example.apbase.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.repository.NoRepositoryBean;

@NoRepositoryBean
public interface BaseRepository<T, ID> extends JpaRepository<T, ID> {
    // 共通のカスタムメソッドを追加可能
}
```

## 4. 共通機能実装

### 4.1 グローバル例外ハンドラ

```java
package com.example.apbase.common.exception;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleException(Exception e) {
        ErrorResponse response = new ErrorResponse(
            HttpStatus.INTERNAL_SERVER_ERROR.value(),
            "Internal Server Error",
            e.getMessage()
        );
        return new ResponseEntity<>(response, HttpStatus.INTERNAL_SERVER_ERROR);
    }

    // その他の例外ハンドラを追加
}
```

### 4.2 ロギング設定

```java
package com.example.apbase.common.logging;

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class LoggingAspect {

    private final Logger logger = LoggerFactory.getLogger(this.getClass());

    @Before("execution(* com.example.apbase..*.*(..))")
    public void logBefore(JoinPoint joinPoint) {
        logger.info("Executing: {}", joinPoint.getSignature().toShortString());
    }
}
```

## 5. 業務機能実装例 (ユーザー管理)

### 5.1 ユーザーコントローラー

```java
package com.example.apbase.user.controller;

import com.example.apbase.controller.BaseController;
import com.example.apbase.user.model.User;
import com.example.apbase.user.service.UserService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/users")
public class UserController extends BaseController<User, Long> {

    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    @Override
    public ResponseEntity<User> create(@RequestBody User user) {
        User createdUser = userService.create(user);
        return ResponseEntity.ok(createdUser);
    }

    @Override
    public ResponseEntity<User> read(@PathVariable Long id) {
        User user = userService.findById(id);
        return ResponseEntity.ok(user);
    }

    // その他のメソッドも同様に実装
}
```

### 5.2 ユーザーサービス

```java
package com.example.apbase.user.service;

import com.example.apbase.service.BaseService;
import com.example.apbase.user.model.User;

public interface UserService extends BaseService<User, Long> {
    // ユーザー固有のメソッドを追加可能
    User findByUsername(String username);
}
```

## 6. 設定クラス

### 6.1 Web設定

```java
package com.example.apbase.common.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // 共通インターセプターを登録
    }
}
```

### 6.2 データベース設定

```java
package com.example.apbase.common.config;

import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

@Configuration
@EntityScan("com.example.apbase.entity")
@EnableJpaRepositories("com.example.apbase.repository")
public class DatabaseConfig {
}
```

## 7. 適用技術スタック

- Spring Boot 3.x
- Spring Data JPA
- Hibernate
- Lombok (ボイラープレートコード削減)
- MapStruct (DTOマッピング)
- Spring Validation
- Spring Security (認証/認可)
- Swagger/OpenAPI (APIドキュメント)

このスケルトン設計をベースに、各業務機能を実装していくことで、一貫性のある保守性の高いアプリケーションを構築できます。共通機能はベースクラスに実装し、業務固有の機能は継承したクラスで実装するようにすることで、コードの重複を防ぎ、開発効率を向上させることができます。