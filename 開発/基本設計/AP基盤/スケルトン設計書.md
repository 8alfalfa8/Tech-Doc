# Spring Boot スケルトン設計書 (AP基盤)

## 1. プロジェクト概要

### 1.1 目的
本設計書は、Spring Bootを基盤としたAP(アプリケーション)開発における標準的なスケルトン構成を定義する。

### 1.2 適用範囲
- 新規開発するSpring BootベースのAPアプリケーション
- マイクロサービスアーキテクチャを採用するシステム
- REST APIを提供するバックエンドサービス

## 2. プロジェクト構造

### 2.1 ディレクトリ構成

```
src/main/java/com/company/[appname]/
├── config/            # 設定関連クラス
├── controller/        # RESTコントローラ
├── service/           # ビジネスロジック
│   ├── impl/          # サービス実装クラス
├── repository/        # データアクセス層
│   ├── entity/        # エンティティクラス
│   ├── dao/           # DAOインターフェース(JPA or MyBatis)
├── dto/               # データ転送オブジェクト
├── exception/         # 例外処理関連
├── util/              # ユーティリティクラス
├── validation/        # バリデーション関連
└── [AppName]Application.java  # メインアプリケーションクラス

src/main/resources/
├── application.yml    # アプリケーション設定
├── application-dev.yml # 開発環境設定
├── application-prod.yml # 本番環境設定
├── messages/          # メッセージプロパティ
├── static/            # 静的リソース
└── templates/         # テンプレートファイル
```

## 3. 技術スタック

### 3.1 基本技術

| カテゴリ       | 技術選定               |
|----------------|------------------------|
| フレームワーク | Spring Boot 3.x        |
| ビルドツール   | Maven/Gradle           |
| 言語           | Java 17+               |
| API仕様        | OpenAPI 3.0            |

### 3.2 主要ライブラリ

| 目的               | ライブラリ                     |
|--------------------|-------------------------------|
| データアクセス     | Spring Data JPA / MyBatis     |
| データベース       | H2 (開発), PostgreSQL (本番)  |
| キャッシュ         | Redis                         |
| 認証・認可         | Spring Security               |
| ロギング           | SLF4J + Logback               |
| テスト             | JUnit 5, Mockito, Testcontainers |
| メトリクス         | Micrometer + Prometheus       |
| APIドキュメント    | SpringDoc OpenAPI             |

## 4. コアコンポーネント設計

### 4.1 アプリケーション設定

```java
@SpringBootApplication
@EnableConfigurationProperties({
    AppProperties.class,
    SecurityProperties.class
})
public class MyAppApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyAppApplication.class, args);
    }
}
```

### 4.2 RESTコントローラ例

```java
@RestController
@RequestMapping("/api/v1/users")
@RequiredArgsConstructor
@Tag(name = "User Management", description = "ユーザー管理API")
public class UserController {

    private final UserService userService;

    @GetMapping
    @Operation(summary = "ユーザー一覧取得")
    public ResponseEntity<Page<UserDto>> getUsers(
            @ParameterObject @PageableDefault Pageable pageable) {
        return ResponseEntity.ok(userService.findAll(pageable));
    }

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    @Operation(summary = "新規ユーザー登録")
    public UserDto createUser(@Valid @RequestBody UserCreateRequest request) {
        return userService.create(request);
    }
}
```

### 4.3 サービス層設計

```java
public interface UserService {
    Page<UserDto> findAll(Pageable pageable);
    UserDto create(UserCreateRequest request);
    UserDto findById(Long id);
}

@Service
@Transactional
@RequiredArgsConstructor
@Slf4j
public class UserServiceImpl implements UserService {

    private final UserRepository userRepository;
    private final ModelMapper modelMapper;

    @Override
    public Page<UserDto> findAll(Pageable pageable) {
        return userRepository.findAll(pageable)
                .map(user -> modelMapper.map(user, UserDto.class));
    }

    @Override
    public UserDto create(UserCreateRequest request) {
        User user = modelMapper.map(request, User.class);
        user = userRepository.save(user);
        return modelMapper.map(user, UserDto.class);
    }
}
```

### 4.4 リポジトリ層設計

```java
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);
    boolean existsByEmail(String email);
}

@Entity
@Table(name = "users")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, unique = true)
    private String email;
    
    @Column(nullable = false)
    private String name;
    
    @CreationTimestamp
    private LocalDateTime createdAt;
    
    @UpdateTimestamp
    private LocalDateTime updatedAt;
}
```

## 5. 共通機能設計

### 5.1 例外処理

```java
@ControllerAdvice
@Slf4j
@RequiredArgsConstructor
public class GlobalExceptionHandler {

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(
            MethodArgumentNotValidException ex) {
        
        List<String> errors = ex.getBindingResult()
                .getFieldErrors()
                .stream()
                .map(error -> error.getField() + ": " + error.getDefaultMessage())
                .collect(Collectors.toList());

        ErrorResponse response = new ErrorResponse(
                "VALIDATION_ERROR",
                "入力値チェックエラー",
                errors);
        
        return ResponseEntity.badRequest().body(response);
    }

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleResourceNotFound(
            ResourceNotFoundException ex) {
        ErrorResponse response = new ErrorResponse(
                "NOT_FOUND",
                ex.getMessage());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
    }
}
```

### 5.2 ロギング設計

```java
@Aspect
@Component
@Slf4j
@RequiredArgsConstructor
public class LoggingAspect {

    @Around("execution(* com.company..*Controller.*(..))")
    public Object logController(ProceedingJoinPoint joinPoint) throws Throwable {
        String className = joinPoint.getTarget().getClass().getSimpleName();
        String methodName = joinPoint.getSignature().getName();
        
        log.info("Controller Start: {}.{}() with argument[s] = {}", 
                className, methodName, Arrays.toString(joinPoint.getArgs()));
        
        try {
            Object result = joinPoint.proceed();
            
            log.info("Controller End: {}.{}() with result = {}", 
                    className, methodName, result);
            
            return result;
        } catch (Exception e) {
            log.error("Exception in {}.{}(): {}", className, methodName, e.getMessage());
            throw e;
        }
    }
}
```

## 6. 設定ファイル例

### 6.1 application.yml

```yaml
spring:
  application:
    name: my-application
  profiles:
    active: dev
  datasource:
    url: jdbc:h2:mem:testdb
    username: sa
    password:
    driver-class-name: org.h2.Driver
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        format_sql: true
  cache:
    type: redis
  redis:
    host: localhost
    port: 6379

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
  endpoint:
    health:
      show-details: always

logging:
  level:
    root: INFO
    org.springframework.web: DEBUG
    com.company: DEBUG
```

## 7. テスト戦略

### 7.1 テスト構成

```
src/test/java/
├── com/company/[appname]/
│   ├── controller/    # コントローラテスト
│   ├── service/       # サービス層テスト
│   ├── repository/    # リポジトリテスト
│   └── integration/   # 統合テスト
└── resources/
    ├── test-data.sql  # テストデータ
    └── application-test.yml # テスト用設定
```

### 7.2 テスト例

```java
@WebMvcTest(UserController.class)
@Import({UserServiceImpl.class, SecurityConfig.class})
@AutoConfigureMockMvc(addFilters = false)
class UserControllerTest {

    @Autowired
    private MockMvc mockMvc;
    
    @MockBean
    private UserRepository userRepository;
    
    @Test
    @DisplayName("ユーザー一覧取得 - 成功")
    void getUsers_success() throws Exception {
        // テストデータ準備
        List<User> users = Arrays.asList(
                new User(1L, "user1@example.com", "User 1"),
                new User(2L, "user2@example.com", "User 2"));
        
        given(userRepository.findAll(any(Pageable.class)))
                .willReturn(new PageImpl<>(users));
        
        // リクエスト実行 & 検証
        mockMvc.perform(get("/api/v1/users")
                .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.content", hasSize(2)))
                .andExpect(jsonPath("$.content[0].email", is("user1@example.com")));
    }
}
```

## 8. デプロイ設計

### 8.1 コンテナ化

```dockerfile
FROM eclipse-temurin:17-jdk-jammy

WORKDIR /app

COPY build/libs/*.jar app.jar

EXPOSE 8080

ENTRYPOINT ["java", "-jar", "app.jar"]
```

### 8.2 CI/CDパイプライン

1. ソースコードチェックアウト
2. ユニットテスト実行
3. ビルド (./gradlew build)
4. コンテナイメージビルド
5. イメージリポジトリへプッシュ
6. デプロイ (Kubernetes/ECSなど)

## 9. セキュリティ設計

### 9.1 セキュリティ設定例

```java
@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthFilter;
    private final AuthenticationProvider authenticationProvider;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(AbstractHttpConfigurer::disable)
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/v1/auth/**").permitAll()
                .requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()
                .anyRequest().authenticated()
            )
            .sessionManagement(sess -> 
                sess.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authenticationProvider(authenticationProvider)
            .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);
        
        return http.build();
    }
}
```

## 10. 監視・運用設計

### 10.1 ヘルスチェック

```java
@RestController
@RequestMapping("/manage")
public class ManagementController {

    @GetMapping("/health")
    public ResponseEntity<String> healthCheck() {
        return ResponseEntity.ok("OK");
    }

    @GetMapping("/info")
    public ResponseEntity<Map<String, String>> appInfo() {
        Map<String, String> info = new HashMap<>();
        info.put("version", "1.0.0");
        info.put("buildTime", Instant.now().toString());
        return ResponseEntity.ok(info);
    }
}
```

### 10.2 メトリクス収集

```yaml
management:
  metrics:
    export:
      prometheus:
        enabled: true
    tags:
      application: ${spring.application.name}
```

以上がSpring Bootを基盤としたAP開発の標準スケルトン設計書となります。プロジェクトの要件に応じて適宜カスタマイズしてください。