# Spring Batch スケルトン設計書 (AP基盤)

## 1. プロジェクト概要

### 1.1 目的
本設計書は、Spring Batchを基盤としたバッチ処理システムの標準的なスケルトン構成を定義する。

### 1.2 適用範囲
- 定期的に実行されるデータ処理バッチ
- 大量データの一括処理
- 長時間実行される非同期処理
- 他のシステムとのデータ連携バッチ

## 2. プロジェクト構造

### 2.1 ディレクトリ構成

```
src/main/java/com/company/[appname]/batch/
├── config/            # バッチ設定クラス
├── job/               # ジョブ定義
├── tasklet/           # タスクレット実装
├── chunk/             # チャンク処理
│   ├── reader/        # ItemReader実装
│   ├── processor/     # ItemProcessor実装
│   └── writer/        # ItemWriter実装
├── listener/          # リスナー類
├── dto/               # バッチ用DTO
├── exception/         # バッチ例外処理
└── BatchApplication.java  # メインクラス

src/main/resources/batch/
├── jobs/              # ジョブ定義(XML)
├── sql/               # SQLファイル
└── schedules/         # スケジュール定義
```

## 3. 技術スタック

### 3.1 基本技術

| カテゴリ       | 技術選定               |
|----------------|------------------------|
| フレームワーク | Spring Boot Batch      |
| バージョン     | Spring Batch 5.x       |
| スケジューラ   | Spring Scheduler / Quartz |
| データアクセス | JPA / MyBatis / JdbcTemplate |

### 3.2 主要ライブラリ

| 目的               | ライブラリ                     |
|--------------------|-------------------------------|
| ロギング           | SLF4J + Logback               |
| テスト             | JUnit 5, Spring Batch Test     |
| メトリクス         | Micrometer + Prometheus       |
| 並列処理           | Spring Batch Partitioning     |
| リトライ           | Spring Retry                  |

## 4. コアコンポーネント設計

### 4.1 バッチジョブ設定例

```java
@Configuration
@RequiredArgsConstructor
public class SampleBatchConfig {

    private final JobBuilderFactory jobBuilderFactory;
    private final StepBuilderFactory stepBuilderFactory;
    private final SampleItemReader sampleItemReader;
    private final SampleItemProcessor sampleItemProcessor;
    private final SampleItemWriter sampleItemWriter;

    @Bean
    public Job sampleJob() {
        return jobBuilderFactory.get("sampleJob")
                .incrementer(new RunIdIncrementer())
                .start(sampleStep())
                .listener(sampleJobListener())
                .build();
    }

    @Bean
    public Step sampleStep() {
        return stepBuilderFactory.get("sampleStep")
                .<InputDto, OutputDto>chunk(1000)
                .reader(sampleItemReader)
                .processor(sampleItemProcessor)
                .writer(sampleItemWriter)
                .faultTolerant()
                .skipLimit(10)
                .skip(DataIntegrityViolationException.class)
                .retryLimit(3)
                .retry(DeadlockLoserDataAccessException.class)
                .listener(sampleStepListener())
                .build();
    }
}
```

### 4.2 ItemReader実装例

```java
@StepScope
@Component
@RequiredArgsConstructor
public class SampleItemReader implements ItemReader<InputDto> {

    private final DataSource dataSource;
    private JdbcCursorItemReader<InputDto> delegate;

    @Value("#{jobParameters[executionDate]}")
    private String executionDate;

    @Override
    public InputDto read() throws Exception {
        if (delegate == null) {
            initializeReader();
        }
        return delegate.read();
    }

    private void initializeReader() {
        delegate = new JdbcCursorItemReaderBuilder<InputDto>()
                .name("sampleItemReader")
                .dataSource(dataSource)
                .sql(getQuery())
                .rowMapper(new BeanPropertyRowMapper<>(InputDto.class))
                .saveState(false)
                .build();
    }

    private String getQuery() {
        return "SELECT id, name, value FROM input_table " +
               "WHERE processing_date = '" + executionDate + "' " +
               "ORDER BY id";
    }
}
```

### 4.3 ItemProcessor実装例

```java
@StepScope
@Component
public class SampleItemProcessor implements ItemProcessor<InputDto, OutputDto> {

    @Override
    public OutputDto process(InputDto item) throws Exception {
        // ビジネスロジックの実行
        OutputDto output = new OutputDto();
        output.setId(item.getId());
        output.setCalculatedValue(calculate(item.getValue()));
        
        if (isInvalid(output)) {
            throw new ValidationException("Invalid data: " + item.getId());
        }
        
        return output;
    }

    private BigDecimal calculate(BigDecimal value) {
        // 計算ロジック
        return value.multiply(new BigDecimal("1.1"));
    }
}
```

### 4.4 ItemWriter実装例

```java
@StepScope
@Component
@RequiredArgsConstructor
public class SampleItemWriter implements ItemWriter<OutputDto> {

    private final JdbcTemplate jdbcTemplate;
    private static final String INSERT_SQL = 
            "INSERT INTO output_table (id, calculated_value, processed_at) " +
            "VALUES (?, ?, CURRENT_TIMESTAMP)";

    @Override
    public void write(List<? extends OutputDto> items) throws Exception {
        List<Object[]> batchArgs = items.stream()
                .map(item -> new Object[]{
                        item.getId(),
                        item.getCalculatedValue()
                })
                .collect(Collectors.toList());
        
        jdbcTemplate.batchUpdate(INSERT_SQL, batchArgs);
    }
}
```

## 5. リスナー設計

### 5.1 JobExecutionListener実装例

```java
@Component
@Slf4j
@RequiredArgsConstructor
public class SampleJobListener implements JobExecutionListener {

    private final JobExecutionLogRepository logRepository;

    @Override
    public void beforeJob(JobExecution jobExecution) {
        log.info("Job {} started", jobExecution.getJobInstance().getJobName());
        
        JobExecutionLog logEntity = new JobExecutionLog();
        logEntity.setJobName(jobExecution.getJobInstance().getJobName());
        logEntity.setStartTime(LocalDateTime.now());
        logEntity.setStatus("STARTED");
        logRepository.save(logEntity);
        
        jobExecution.getExecutionContext().put("logId", logEntity.getId());
    }

    @Override
    public void afterJob(JobExecution jobExecution) {
        String status = jobExecution.getStatus().toString();
        log.info("Job {} completed with status {}", 
                jobExecution.getJobInstance().getJobName(), 
                status);
        
        Long logId = jobExecution.getExecutionContext().getLong("logId");
        JobExecutionLog logEntity = logRepository.findById(logId)
                .orElseThrow();
        
        logEntity.setEndTime(LocalDateTime.now());
        logEntity.setStatus(status);
        logEntity.setExitCode(jobExecution.getExitStatus().getExitCode());
        logRepository.save(logEntity);
    }
}
```

### 5.2 StepExecutionListener実装例

```java
@Component
@Slf4j
public class SampleStepListener implements StepExecutionListener {

    @Override
    public void beforeStep(StepExecution stepExecution) {
        log.info("Step {} started", stepExecution.getStepName());
    }

    @Override
    public ExitStatus afterStep(StepExecution stepExecution) {
        log.info("Step {} completed - Read: {}, Processed: {}, Written: {}, Skipped: {}", 
                stepExecution.getStepName(),
                stepExecution.getReadCount(),
                stepExecution.getProcessSkipCount(),
                stepExecution.getWriteCount(),
                stepExecution.getSkipCount());
        
        return null; // デフォルトのExitStatusをそのまま使用
    }
}
```

## 6. バッチ起動方法

### 6.1 コマンドライン起動

```java
@SpringBootApplication
@EnableBatchProcessing
public class BatchApplication implements CommandLineRunner {

    private final JobLauncher jobLauncher;
    private final Job sampleJob;

    public static void main(String[] args) {
        SpringApplication.run(BatchApplication.class, args);
    }

    @Override
    public void run(String... args) throws Exception {
        JobParameters jobParameters = new JobParametersBuilder()
                .addString("executionDate", LocalDate.now().toString())
                .addLong("timestamp", System.currentTimeMillis())
                .toJobParameters();
        
        jobLauncher.run(sampleJob, jobParameters);
    }
}
```

### 6.2 スケジュール起動

```java
@Configuration
@EnableScheduling
public class BatchScheduler {

    private final JobLauncher jobLauncher;
    private final Job sampleJob;

    @Scheduled(cron = "0 0 3 * * ?") // 毎日3:00に実行
    public void runSampleJob() throws Exception {
        JobParameters jobParameters = new JobParametersBuilder()
                .addString("executionDate", LocalDate.now().toString())
                .addLong("timestamp", System.currentTimeMillis())
                .toJobParameters();
        
        jobLauncher.run(sampleJob, jobParameters);
    }
}
```

## 7. バッチ管理設計

### 7.1 メトリクス収集

```java
@Configuration
public class BatchMetricsConfig {

    @Bean
    public MeterRegistryPostProcessor meterRegistryPostProcessor(MeterRegistry registry) {
        return new MeterRegistryPostProcessor(registry);
    }

    @Bean
    public JobExecutionMetrics jobExecutionMetrics() {
        return new JobExecutionMetrics();
    }

    @Bean
    public StepExecutionMetrics stepExecutionMetrics() {
        return new StepExecutionMetrics();
    }
}
```

### 7.2 バッチ実行履歴管理

```java
@Entity
@Table(name = "batch_execution_log")
@Getter
@Setter
@NoArgsConstructor
public class JobExecutionLog {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String jobName;
    
    @Column(nullable = false)
    private LocalDateTime startTime;
    
    private LocalDateTime endTime;
    
    @Column(nullable = false)
    private String status;
    
    private String exitCode;
    
    @Column(length = 4000)
    private String errorMessage;
}
```

## 8. エラー処理設計

### 8.1 カスタム例外クラス

```java
public class BatchProcessingException extends RuntimeException {

    private final ErrorCode errorCode;
    private final String detail;

    public BatchProcessingException(ErrorCode errorCode, String detail) {
        super(errorCode.getMessage() + ": " + detail);
        this.errorCode = errorCode;
        this.detail = detail;
    }

    public enum ErrorCode {
        DATA_VALIDATION_ERROR("データ検証エラー"),
        DATA_INTEGRITY_ERROR("データ整合性エラー"),
        SYSTEM_ERROR("システムエラー");
        
        private final String message;
        
        ErrorCode(String message) {
            this.message = message;
        }
        
        public String getMessage() {
            return message;
        }
    }
}
```

### 8.2 エラーハンドリングリスナー

```java
@Component
public class BatchErrorHandler implements JobExecutionListener {

    @Override
    public void afterJob(JobExecution jobExecution) {
        if (jobExecution.getStatus() == BatchStatus.FAILED) {
            for (StepExecution stepExecution : jobExecution.getStepExecutions()) {
                if (stepExecution.getFailureExceptions() != null && 
                    !stepExecution.getFailureExceptions().isEmpty()) {
                    
                    log.error("Step {} failed with exceptions:", 
                            stepExecution.getStepName());
                    
                    stepExecution.getFailureExceptions().forEach(ex -> 
                            log.error("Exception: ", ex));
                }
            }
            
            // エラー通知処理
            sendErrorNotification(jobExecution);
        }
    }

    private void sendErrorNotification(JobExecution jobExecution) {
        // メールやSlackなどでの通知処理を実装
    }
}
```

## 9. テスト戦略

### 9.1 テスト構成

```
src/test/java/com/company/[appname]/batch/
├── config/            # 設定テスト
├── job/               # ジョブテスト
├── chunk/             # チャンク処理テスト
└── BatchTestConfig.java # テスト設定
```

### 9.2 バッチテスト例

```java
@SpringBatchTest
@SpringBootTest
@ExtendWith(SpringExtension.class)
class SampleBatchJobTest {

    @Autowired
    private JobLauncherTestUtils jobLauncherTestUtils;

    @Autowired
    private DataSource dataSource;

    @BeforeEach
    void setup() throws Exception {
        // テストデータ準備
        JdbcTestUtils.deleteFromTables(
                jdbcTemplate, "input_table", "output_table");
        
        jdbcTemplate.execute(
                "INSERT INTO input_table (id, name, value, processing_date) " +
                "VALUES (1, 'Test1', 100, '2023-01-01')");
    }

    @Test
    void testSampleJob() throws Exception {
        // ジョブ実行
        JobExecution jobExecution = jobLauncherTestUtils.launchJob(
                new JobParametersBuilder()
                        .addString("executionDate", "2023-01-01")
                        .addLong("timestamp", System.currentTimeMillis())
                        .toJobParameters());
        
        // 結果検証
        assertThat(jobExecution.getExitStatus()).isEqualTo(ExitStatus.COMPLETED);
        
        int count = JdbcTestUtils.countRowsInTableWhere(
                jdbcTemplate, 
                "output_table", 
                "calculated_value = 110");
        
        assertThat(count).isEqualTo(1);
    }
}
```

## 10. デプロイ設計

### 10.1 バッチサーバー構成

```markdown
- **構成要件**:
  - スケジュール実行用の常駐プロセス
  - リソース監視(CPU,メモリ,ディスク)
  - 複数サーバーでのクラスタ構成可能
  - ジョブの排他制御機構

- **推奨環境**:
  - Java 17+
  - メモリ: 4GB以上(処理内容による)
  - ディスク: ログ保存用に十分な領域
```

### 10.2 コンテナ化例 (Dockerfile)

```dockerfile
FROM eclipse-temurin:17-jdk-jammy

WORKDIR /app

COPY build/libs/*.jar app.jar

# バッチ実行用のエントリーポイント
ENTRYPOINT ["java", "-jar", "app.jar", "--spring.batch.job.names=sampleJob"]
```

## 11. パフォーマンスチューニング

### 11.1 チューニングポイント

| 項目               | 対策                                   |
|--------------------|----------------------------------------|
| メモリ使用量       | チャンクサイズ最適化                   |
| 処理速度           | 並列処理(Partitioning/Multi-threading) |
| データベース負荷   | フェッチサイズ調整                     |
| リソース競合       | スレッドプール設定                     |

### 11.2 並列処理設定例

```java
@Bean
public Job partitionedJob() {
    return jobBuilderFactory.get("partitionedJob")
            .start(partitionStep())
            .build();
}

@Bean
public Step partitionStep() {
    return stepBuilderFactory.get("partitionStep")
            .partitioner("slaveStep", partitioner())
            .step(slaveStep())
            .gridSize(10)
            .taskExecutor(taskExecutor())
            .build();
}

@Bean
public TaskExecutor taskExecutor() {
    ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
    executor.setCorePoolSize(5);
    executor.setMaxPoolSize(10);
    executor.setQueueCapacity(25);
    return executor;
}
```

## 12. 運用設計

### 12.1 監視項目

| 項目               | 監視方法                     |
|--------------------|------------------------------|
| ジョブ実行状況     | データベースログ             |
| 処理時間           | Prometheusメトリクス         |
| エラー発生         | ログ監視(Splunk/ELK等)       |
| リソース使用量     | クラウド監視ツール           |

### 12.2 運用ルール

1. **再実行ルール**:
   - 一時的なエラー: 自動リトライ(最大3回)
   - データエラー: 管理者通知後、手動再実行
   - システムエラー: 根本原因修正後に再実行

2. **ログ保持ポリシー**:
   - 実行ログ: 3ヶ月
   - 監査ログ: 1年
   - エラーログ: 6ヶ月

3. **メンテナンス**:
   - バッチ実行履歴の定期的なアーカイブ
   - Spring Batchメタデータのクリーンアップ(30日以上前のデータ)

以上がSpring Batchを基盤としたバッチ処理システムの標準スケルトン設計書となります。プロジェクトの要件に応じて適宜カスタマイズしてください。