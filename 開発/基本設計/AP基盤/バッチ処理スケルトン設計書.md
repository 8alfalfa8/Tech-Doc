# Spring Batch スケルトン設計書 (AP基盤)

## 1. プロジェクト概要

### 1.1 目的
本設計書は、Spring Batchを基盤としたバッチ処理システムの標準的なスケルトン構成を定義する。

### 1.2 適用範囲
- 定期的に実行されるデータ処理バッチ
- 大量データの一括処理
- 長時間実行される非同期処理
- 他のシステムとのデータ連携バッチ

## 2. プロジェクト構造

### 2.1 ディレクトリ構成

```
src/main/java/com/company/[appname]/batch/
├── config/            # バッチ設定クラス
├── job/               # ジョブ定義
├── tasklet/           # タスクレット実装
├── chunk/             # チャンク処理
│   ├── reader/        # ItemReader実装
│   ├── processor/     # ItemProcessor実装
│   └── writer/        # ItemWriter実装
├── listener/          # リスナー類
├── dto/               # バッチ用DTO
├── exception/         # バッチ例外処理
└── BatchApplication.java  # メインクラス

src/main/resources/batch/
├── jobs/              # ジョブ定義(XML)
├── sql/               # SQLファイル
└── schedules/         # スケジュール定義
```

## 3. 技術スタック

### 3.1 基本技術

| カテゴリ       | 技術選定               |
|----------------|------------------------|
| フレームワーク | Spring Boot Batch      |
| バージョン     | Spring Batch 5.x       |
| スケジューラ   | Spring Scheduler / Quartz |
| データアクセス | JPA / MyBatis / JdbcTemplate |

### 3.2 主要ライブラリ

| 目的               | ライブラリ                     |
|--------------------|-------------------------------|
| ロギング           | SLF4J + Logback               |
| テスト             | JUnit 5, Spring Batch Test     |
| メトリクス         | Micrometer + Prometheus       |
| 並列処理           | Spring Batch Partitioning     |
| リトライ           | Spring Retry                  |

## 4. コアコンポーネント設計

### 4.1 バッチジョブ設定例

```java
@Configuration
@RequiredArgsConstructor
public class SampleBatchConfig {

    private final JobBuilderFactory jobBuilderFactory;
    private final StepBuilderFactory stepBuilderFactory;
    private final SampleItemReader sampleItemReader;
    private final SampleItemProcessor sampleItemProcessor;
    private final SampleItemWriter sampleItemWriter;

    @Bean
    public Job sampleJob() {
        return jobBuilderFactory.get("sampleJob")
                .incrementer(new RunIdIncrementer())
                .start(sampleStep())
                .listener(sampleJobListener())
                .build();
    }

    @Bean
    public Step sampleStep() {
        return stepBuilderFactory.get("sampleStep")
                .<InputDto, OutputDto>chunk(1000)
                .reader(sampleItemReader)
                .processor(sampleItemProcessor)
                .writer(sampleItemWriter)
                .faultTolerant()
                .skipLimit(10)
                .skip(DataIntegrityViolationException.class)
                .retryLimit(3)
                .retry(DeadlockLoserDataAccessException.class)
                .listener(sampleStepListener())
                .build();
    }
}
```

### 4.2 ItemReader実装例

```java
@StepScope
@Component
@RequiredArgsConstructor
public class SampleItemReader implements ItemReader<InputDto> {

    private final DataSource dataSource;
    private JdbcCursorItemReader<InputDto> delegate;

    @Value("#{jobParameters[executionDate]}")
    private String executionDate;

    @Override
    public InputDto read() throws Exception {
        if (delegate == null) {
            initializeReader();
        }
        return delegate.read();
    }

    private void initializeReader() {
        delegate = new JdbcCursorItemReaderBuilder<InputDto>()
                .name("sampleItemReader")
                .dataSource(dataSource)
                .sql(getQuery())
                .rowMapper(new BeanPropertyRowMapper<>(InputDto.class))
                .saveState(false)
                .build();
    }

    private String getQuery() {
        return "SELECT id, name, value FROM input_table " +
               "WHERE processing_date = '" + executionDate + "' " +
               "ORDER BY id";
    }
}
```

### 4.3 ItemProcessor実装例

```java
@StepScope
@Component
public class SampleItemProcessor implements ItemProcessor<InputDto, OutputDto> {

    @Override
    public OutputDto process(InputDto item) throws Exception {
        // ビジネスロジックの実行
        OutputDto output = new OutputDto();
        output.setId(item.getId());
        output.setCalculatedValue(calculate(item.getValue()));
        
        if (isInvalid(output)) {
            throw new ValidationException("Invalid data: " + item.getId());
        }
        
        return output;
    }

    private BigDecimal calculate(BigDecimal value) {
        // 計算ロジック
        return value.multiply(new BigDecimal("1.1"));
    }
}
```

### 4.4 ItemWriter実装例

```java
@StepScope
@Component
@RequiredArgsConstructor
public class SampleItemWriter implements ItemWriter<OutputDto> {

    private final JdbcTemplate jdbcTemplate;
    private static final String INSERT_SQL = 
            "INSERT INTO output_table (id, calculated_value, processed_at) " +
            "VALUES (?, ?, CURRENT_TIMESTAMP)";

    @Override
    public void write(List<? extends OutputDto> items) throws Exception {
        List<Object[]> batchArgs = items.stream()
                .map(item -> new Object[]{
                        item.getId(),
                        item.getCalculatedValue()
                })
                .collect(Collectors.toList());
        
        jdbcTemplate.batchUpdate(INSERT_SQL, batchArgs);
    }
}
```

## 5. リスナー設計

### 5.1 JobExecutionListener実装例

```java
@Component
@Slf4j
@RequiredArgsConstructor
public class SampleJobListener implements JobExecutionListener {

    private final JobExecutionLogRepository logRepository;

    @Override
    public void beforeJob(JobExecution jobExecution) {
        log.info("Job {} started", jobExecution.getJobInstance().getJobName());
        
        JobExecutionLog logEntity = new JobExecutionLog();
        logEntity.setJobName(jobExecution.getJobInstance().getJobName());
        logEntity.setStartTime(LocalDateTime.now());
        logEntity.setStatus("STARTED");
        logRepository.save(logEntity);
        
        jobExecution.getExecutionContext().put("logId", logEntity.getId());
    }

    @Override
    public void afterJob(JobExecution jobExecution) {
        String status = jobExecution.getStatus().toString();
        log.info("Job {} completed with status {}", 
                jobExecution.getJobInstance().getJobName(), 
                status);
        
        Long logId = jobExecution.getExecutionContext().getLong("logId");
        JobExecutionLog logEntity = logRepository.findById(logId)
                .orElseThrow();
        
        logEntity.setEndTime(LocalDateTime.now());
        logEntity.setStatus(status);
        logEntity.setExitCode(jobExecution.getExitStatus().getExitCode());
        logRepository.save(logEntity);
    }
}
```

### 5.2 StepExecutionListener実装例

```java
@Component
@Slf4j
public class SampleStepListener implements StepExecutionListener {

    @Override
    public void beforeStep(StepExecution stepExecution) {
        log.info("Step {} started", stepExecution.getStepName());
    }

    @Override
    public ExitStatus afterStep(StepExecution stepExecution) {
        log.info("Step {} completed - Read: {}, Processed: {}, Written: {}, Skipped: {}", 
                stepExecution.getStepName(),
                stepExecution.getReadCount(),
                stepExecution.getProcessSkipCount(),
                stepExecution.getWriteCount(),
                stepExecution.getSkipCount());
        
        return null; // デフォルトのExitStatusをそのまま使用
    }
}
```

## 6. バッチ起動方法

### 6.1 コマンドライン起動

```java
@SpringBootApplication
@EnableBatchProcessing
public class BatchApplication implements CommandLineRunner {

    private final JobLauncher jobLauncher;
    private final Job sampleJob;

    public static void main(String[] args) {
        SpringApplication.run(BatchApplication.class, args);
    }

    @Override
    public void run(String... args) throws Exception {
        JobParameters jobParameters = new JobParametersBuilder()
                .addString("executionDate", LocalDate.now().toString())
                .addLong("timestamp", System.currentTimeMillis())
                .toJobParameters();
        
        jobLauncher.run(sampleJob, jobParameters);
    }
}
```

### 6.2 スケジュール起動

```java
@Configuration
@EnableScheduling
public class BatchScheduler {

    private final JobLauncher jobLauncher;
    private final Job sampleJob;

    @Scheduled(cron = "0 0 3 * * ?") // 毎日3:00に実行
    public void runSampleJob() throws Exception {
        JobParameters jobParameters = new JobParametersBuilder()
                .addString("executionDate", LocalDate.now().toString())
                .addLong("timestamp", System.currentTimeMillis())
                .toJobParameters();
        
        jobLauncher.run(sampleJob, jobParameters);
    }
}
```

## 7. バッチ管理設計

### 7.1 メトリクス収集

```java
@Configuration
public class BatchMetricsConfig {

    @Bean
    public MeterRegistryPostProcessor meterRegistryPostProcessor(MeterRegistry registry) {
        return new MeterRegistryPostProcessor(registry);
    }

    @Bean
    public JobExecutionMetrics jobExecutionMetrics() {
        return new JobExecutionMetrics();
    }

    @Bean
    public StepExecutionMetrics stepExecutionMetrics() {
        return new StepExecutionMetrics();
    }
}
```

### 7.2 バッチ実行履歴管理

```java
@Entity
@Table(name = "batch_execution_log")
@Getter
@Setter
@NoArgsConstructor
public class JobExecutionLog {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String jobName;
    
    @Column(nullable = false)
    private LocalDateTime startTime;
    
    private LocalDateTime endTime;
    
    @Column(nullable = false)
    private String status;
    
    private String exitCode;
    
    @Column(length = 4000)
    private String errorMessage;
}
```

## 8. エラー処理設計

### 8.1 カスタム例外クラス

```java
public class BatchProcessingException extends RuntimeException {

    private final ErrorCode errorCode;
    private final String detail;

    public BatchProcessingException(ErrorCode errorCode, String detail) {
        super(errorCode.getMessage() + ": " + detail);
        this.errorCode = errorCode;
        this.detail = detail;
    }

    public enum ErrorCode {
        DATA_VALIDATION_ERROR("データ検証エラー"),
        DATA_INTEGRITY_ERROR("データ整合性エラー"),
        SYSTEM_ERROR("システムエラー");
        
        private final String message;
        
        ErrorCode(String message) {
            this.message = message;
        }
        
        public String getMessage() {
            return message;
        }
    }
}
```

### 8.2 エラーハンドリングリスナー

```java
@Component
public class BatchErrorHandler implements JobExecutionListener {

    @Override
    public void afterJob(JobExecution jobExecution) {
        if (jobExecution.getStatus() == BatchStatus.FAILED) {
            for (StepExecution stepExecution : jobExecution.getStepExecutions()) {
                if (stepExecution.getFailureExceptions() != null && 
                    !stepExecution.getFailureExceptions().isEmpty()) {
                    
                    log.error("Step {} failed with exceptions:", 
                            stepExecution.getStepName());
                    
                    stepExecution.getFailureExceptions().forEach(ex -> 
                            log.error("Exception: ", ex));
                }
            }
            
            // エラー通知処理
            sendErrorNotification(jobExecution);
        }
    }

    private void sendErrorNotification(JobExecution jobExecution) {
        // メールやSlackなどでの通知処理を実装
    }
}
```

## 9. テスト戦略

### 9.1 テスト構成

```
src/test/java/com/company/[appname]/batch/
├── config/            # 設定テスト
├── job/               # ジョブテスト
├── chunk/             # チャンク処理テスト
└── BatchTestConfig.java # テスト設定
```

### 9.2 バッチテスト例

```java
@SpringBatchTest
@SpringBootTest
@ExtendWith(SpringExtension.class)
class SampleBatchJobTest {

    @Autowired
    private JobLauncherTestUtils jobLauncherTestUtils;

    @Autowired
    private DataSource dataSource;

    @BeforeEach
    void setup() throws Exception {
        // テストデータ準備
        JdbcTestUtils.deleteFromTables(
                jdbcTemplate, "input_table", "output_table");
        
        jdbcTemplate.execute(
                "INSERT INTO input_table (id, name, value, processing_date) " +
                "VALUES (1, 'Test1', 100, '2023-01-01')");
    }

    @Test
    void testSampleJob() throws Exception {
        // ジョブ実行
        JobExecution jobExecution = jobLauncherTestUtils.launchJob(
                new JobParametersBuilder()
                        .addString("executionDate", "2023-01-01")
                        .addLong("timestamp", System.currentTimeMillis())
                        .toJobParameters());
        
        // 結果検証
        assertThat(jobExecution.getExitStatus()).isEqualTo(ExitStatus.COMPLETED);
        
        int count = JdbcTestUtils.countRowsInTableWhere(
                jdbcTemplate, 
                "output_table", 
                "calculated_value = 110");
        
        assertThat(count).isEqualTo(1);
    }
}
```

## 10. デプロイ設計

### 10.1 バッチサーバー構成

```markdown
- **構成要件**:
  - スケジュール実行用の常駐プロセス
  - リソース監視(CPU,メモリ,ディスク)
  - 複数サーバーでのクラスタ構成可能
  - ジョブの排他制御機構

- **推奨環境**:
  - Java 17+
  - メモリ: 4GB以上(処理内容による)
  - ディスク: ログ保存用に十分な領域
```

### 10.2 コンテナ化例 (Dockerfile)

```dockerfile
FROM eclipse-temurin:17-jdk-jammy

WORKDIR /app

COPY build/libs/*.jar app.jar

# バッチ実行用のエントリーポイント
ENTRYPOINT ["java", "-jar", "app.jar", "--spring.batch.job.names=sampleJob"]
```

## 11. パフォーマンスチューニング

### 11.1 チューニングポイント

| 項目               | 対策                                   |
|--------------------|----------------------------------------|
| メモリ使用量       | チャンクサイズ最適化                   |
| 処理速度           | 並列処理(Partitioning/Multi-threading) |
| データベース負荷   | フェッチサイズ調整                     |
| リソース競合       | スレッドプール設定                     |

### 11.2 並列処理設定例

```java
@Bean
public Job partitionedJob() {
    return jobBuilderFactory.get("partitionedJob")
            .start(partitionStep())
            .build();
}

@Bean
public Step partitionStep() {
    return stepBuilderFactory.get("partitionStep")
            .partitioner("slaveStep", partitioner())
            .step(slaveStep())
            .gridSize(10)
            .taskExecutor(taskExecutor())
            .build();
}

@Bean
public TaskExecutor taskExecutor() {
    ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
    executor.setCorePoolSize(5);
    executor.setMaxPoolSize(10);
    executor.setQueueCapacity(25);
    return executor;
}
```

## 12. 運用設計

### 12.1 監視項目

| 項目               | 監視方法                     |
|--------------------|------------------------------|
| ジョブ実行状況     | データベースログ             |
| 処理時間           | Prometheusメトリクス         |
| エラー発生         | ログ監視(Splunk/ELK等)       |
| リソース使用量     | クラウド監視ツール           |

### 12.2 運用ルール

1. **再実行ルール**:
   - 一時的なエラー: 自動リトライ(最大3回)
   - データエラー: 管理者通知後、手動再実行
   - システムエラー: 根本原因修正後に再実行

2. **ログ保持ポリシー**:
   - 実行ログ: 3ヶ月
   - 監査ログ: 1年
   - エラーログ: 6ヶ月

3. **メンテナンス**:
   - バッチ実行履歴の定期的なアーカイブ
   - Spring Batchメタデータのクリーンアップ(30日以上前のデータ)

以上がSpring Batchを基盤としたバッチ処理システムの標準スケルトン設計書となります。プロジェクトの要件に応じて適宜カスタマイズしてください。

---

# SpringBatch スケルトン設計書 (AP基盤)

## 1. 設計方針
- 共通機能はスケルトンクラスに実装し、業務毎のバッチはこれを継承して開発する
- 以下の共通機能をスケルトンに実装:
  - バッチ起動パラメータの検証
  - 例外処理
  - ロギング
  - 性能計測
  - ジョブ実行コンテキスト管理
  - リトライ処理
  - トランザクション管理
  - 通知処理

## 2. クラス設計

### 2.1 基底クラス (スケルトン)

#### AbstractBatchJob (抽象クラス)
```java
/**
 * バッチジョブの基底抽象クラス
 */
public abstract class AbstractBatchJob implements Job {

    protected final Logger logger = LoggerFactory.getLogger(getClass());

    @Autowired
    protected JobBuilderFactory jobBuilderFactory;

    @Autowired
    protected StepBuilderFactory stepBuilderFactory;

    @Autowired
    protected JobExecutionListener jobExecutionListener;

    /**
     * ジョブを構築
     */
    @Override
    public Job buildJob() {
        return jobBuilderFactory.get(getJobName())
                .listener(jobExecutionListener)
                .start(mainStep())
                .build();
    }

    /**
     * メインステップを構築
     */
    protected abstract Step mainStep();

    /**
     * ジョブ名を取得 (実装クラスで定義)
     */
    protected abstract String getJobName();

    /**
     * バッチパラメータを検証
     */
    protected void validateParameters(JobParameters parameters) {
        // 共通パラメータ検証ロジック
    }
}
```

#### AbstractBatchStep (抽象クラス)
```java
/**
 * バッチステップの基底抽象クラス
 */
public abstract class AbstractBatchStep<I, O> {

    protected final Logger logger = LoggerFactory.getLogger(getClass());

    /**
     * ステップを構築
     */
    public Step buildStep(StepBuilderFactory stepBuilderFactory, String stepName) {
        return stepBuilderFactory.get(stepName)
                .<I, O>chunk(getChunkSize())
                .reader(reader())
                .processor(processor())
                .writer(writer())
                .faultTolerant()
                .retryLimit(getRetryLimit())
                .retry(getRetryableExceptions())
                .listener(stepExecutionListener())
                .build();
    }

    // 以下、実装クラスでオーバーライド可能なメソッド

    protected int getChunkSize() {
        return 100; // デフォルトチャンクサイズ
    }

    protected int getRetryLimit() {
        return 3; // デフォルトリトライ回数
    }

    protected Class<? extends Throwable>[] getRetryableExceptions() {
        return new Class[]{Exception.class}; // デフォルトで全ての例外をリトライ
    }

    protected abstract ItemReader<I> reader();

    protected abstract ItemProcessor<I, O> processor();

    protected abstract ItemWriter<O> writer();

    protected abstract StepExecutionListener stepExecutionListener();
}
```

### 2.2 共通コンポーネント

#### BatchJobExecutionListener
```java
/**
 * ジョブ実行リスナー (共通処理)
 */
@Component
public class BatchJobExecutionListener extends JobExecutionListenerSupport {

    @Override
    public void beforeJob(JobExecution jobExecution) {
        // ジョブ開始前処理 (開始ログ、初期化処理等)
    }

    @Override
    public void afterJob(JobExecution jobExecution) {
        // ジョブ終了後処理 (終了ログ、リソース解放、通知処理等)
    }
}
```

#### BatchStepExecutionListener
```java
/**
 * ステップ実行リスナー (共通処理)
 */
public class BatchStepExecutionListener implements StepExecutionListener {

    @Override
    public void beforeStep(StepExecution stepExecution) {
        // ステップ開始前処理
    }

    @Override
    public ExitStatus afterStep(StepExecution stepExecution) {
        // ステップ終了後処理
        return stepExecution.getExitStatus();
    }
}
```

## 3. 業務バッチ実装例

### SampleBatchJob (具体クラス)
```java
/**
 * サンプルバッチジョブ
 */
@Component
public class SampleBatchJob extends AbstractBatchJob {

    @Autowired
    private SampleBatchStep sampleBatchStep;

    @Override
    protected Step mainStep() {
        return sampleBatchStep.buildStep(stepBuilderFactory, "sampleStep");
    }

    @Override
    protected String getJobName() {
        return "sampleBatchJob";
    }
}
```

### SampleBatchStep (具体クラス)
```java
/**
 * サンプルバッチステップ
 */
@Component
public class SampleBatchStep extends AbstractBatchStep<String, String> {

    @Override
    protected ItemReader<String> reader() {
        return new SampleItemReader();
    }

    @Override
    protected ItemProcessor<String, String> processor() {
        return new SampleItemProcessor();
    }

    @Override
    protected ItemWriter<String> writer() {
        return new SampleItemWriter();
    }

    @Override
    protected StepExecutionListener stepExecutionListener() {
        return new BatchStepExecutionListener();
    }

    @Override
    protected int getChunkSize() {
        return 50; // 業務ごとにチャンクサイズを変更
    }
}
```

## 4. 設定ファイル例

### application.yml
```yaml
spring:
  batch:
    job:
      enabled: true
    initialize-schema: always # 開発環境用 (本番では変更)
    table-prefix: BATCH_ # バッチテーブルプレフィックス

logging:
  level:
    org.springframework.batch: INFO
    com.example.batch: DEBUG
```

## 5. ディレクトリ構成
```
src/main/java/
└── com/example/batch/
    ├── config/              # 設定クラス
    ├── core/               # コア機能
    │   ├── abstract/       # 抽象クラス
    │   ├── listener/       # リスナー類
    │   └── util/           # ユーティリティ
    ├── job/                # ジョブ実装
    │   ├── sample/         # サンプルジョブ
    │   └── ...             # その他ジョブ
    └── BatchApplication.java # 起動クラス
```

## 6. 拡張ポイント
1. 独自のリスナーを追加する場合: `AbstractBatchJob` にリスナー追加メソッドを実装
2. 独自のエラー処理を追加する場合: `AbstractBatchStep` の `faultTolerant()` 部分を拡張
3. 非同期処理が必要な場合: `TaskExecutor` を設定してステップに追加
4. 並列処理が必要な場合: `Partitioner` を実装してパーティションステップを追加

この設計により、業務ごとのバッチ開発では共通機能を意識せずにビジネスロジックに集中できるようになります。