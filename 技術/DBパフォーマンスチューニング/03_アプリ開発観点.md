---

# 🚀 データベースパフォーマンスチューニング（アプリ開発観点）

---

## ✅ アプリ開発観点のデータベースパフォーマンスチューニング

アプリケーション側から行うデータベースパフォーマンスチューニングには、**SQLの最適化・接続方法・ORMの使い方・キャッシュ戦略・トランザクション管理**など、いくつかの観点があります。以下、それぞれを詳しく説明します。

---

### ✅ 1. SQLクエリの最適化

#### ● 不要なクエリの削減

* 無駄なSELECTやUPDATE、JOINがないか確認。
* 同じクエリを何度も発行していないか（N+1問題など）。

#### ● 必要なカラムのみ取得

```sql
-- Bad
SELECT * FROM users;

-- Good
SELECT id, name, email FROM users;
```

#### ● WHERE句とインデックスの活用

* 条件にインデックスが効くように書く。
* 関数を使うとインデックスが効かなくなる場合があるので注意。

```sql
-- 悪い例（インデックス効かない）
WHERE DATE(created_at) = '2023-01-01'

-- 良い例（インデックス効く）
WHERE created_at BETWEEN '2023-01-01' AND '2023-01-01 23:59:59'
```

#### ● LIMITの活用とページネーション

* 全件取得しない。画面で必要な件数だけを取得。
* 例えば `LIMIT 100 OFFSET 0` など。

---

### ✅ 2. ORMの使い方（ActiveRecord, SQLAlchemy, TypeORMなど）

#### ● N+1クエリの回避

* 関連データを一括で取得する (`eager loading`)

```python
# SQLAlchemy例
session.query(User).options(joinedload(User.posts)).all()
```

#### ● 不要なlazy loadを避ける

* ORMが内部で勝手に複数クエリを投げていないかログで確認。

---

### ✅ 3. キャッシュ戦略

#### ● アプリ側でのキャッシュ

* 頻繁にアクセスされる読み取り専用データ（マスターデータなど）はアプリ内やメモリにキャッシュ。
* Python: `functools.lru_cache`、Node.js: `node-cache` など。

#### ● Redis等を使ったキャッシュ

* 例）ユーザー情報や検索結果をキャッシュに保存しておく。

---

### ✅ 4. データベース接続の最適化

#### ● コネクションプール

* DB接続数を制御。大量の接続でDBがパンクしないように。
* `pool_size`, `max_connections`, `timeout` などを調整。

```python
# SQLAlchemy
create_engine("postgresql://...", pool_size=10, max_overflow=5)
```

#### ● 接続の開けっ放し防止

* トランザクションの開始後に放置されていないか。
* DBセッションを適切にクローズしているか。

---

### ✅ 5. トランザクション管理

#### ● 適切な粒度のトランザクション

* 長時間トランザクションを避け、必要な処理のみを囲む。

```python
# Python pseudo code
with session.begin():
    update_a()
    update_b()
```

#### ● ロック競合の回避

* 頻繁に更新される行へのアクセスは競合が起きないように順序制御やキュー処理を検討。

---

### ✅ 6. ログとモニタリングによる分析

#### ● スロークエリログの確認

* DB側でslow query logをONにし、アプリからの実行時間の長いSQLを特定。

#### ● APM（Application Performance Monitoring）の導入

* Datadog / NewRelic / Sentry / OpenTelemetry などでトレースを見る。

---

### ✅ 7. その他アプリでできる工夫

#### ● バルクインサート・アップデート

* 複数行を1クエリで処理する。

```sql
INSERT INTO users (name, email) VALUES ('Alice', 'a@example.com'), ('Bob', 'b@example.com')
```

#### ● 分割バッチ処理

* 大量データを一度に処理せず、小分けにしてクエリ送信。

---

### 🔍 実例（Python + SQLAlchemy）

```python
from sqlalchemy.orm import joinedload

# 悪い例：N+1が起きる
users = session.query(User).all()
for user in users:
    print(user.posts)  # 各ユーザーで1クエリ発行

# 良い例：一括で関連データを取得
users = session.query(User).options(joinedload(User.posts)).all()
```

---

### 🔚 まとめ

| 観点       | チューニング例              |
| -------- | -------------------- |
| SQL      | 必要なカラムのみ取得、インデックス考慮  |
| ORM      | N+1回避、lazy load制御    |
| キャッシュ    | Redis等で読み取り高速化       |
| 接続       | コネクションプール設定、クローズ漏れ防止 |
| トランザクション | 最小化しロック競合を避ける        |
| モニタリング   | APMやスロークエリログで分析      |

---

## 実行計画（Execution Plan）利用

SQLの**実行計画（Execution Plan）を利用したパフォーマンスチューニング**は、アプリケーションから発行されるSQLが**どのようにデータベース内部で処理されているかを可視化・分析**し、ボトルネックを発見・改善するための極めて重要な方法です。

以下、**概念 → 主要ツール → 分析手順 → チューニングポイント**の順で詳しくご説明します。

---

### ✅ 1. 実行計画（Execution Plan）とは？

SQLが実行される際、DBエンジンは以下の順序で処理します：

1. **パーサー**がSQL文の構文をチェック
2. **オプティマイザ**が複数の実行パスから最も効率的な方法（コストが最小）を選択
3. \*\*実行計画（execution plan）\*\*が生成され、それに基づき実行

👉 実行計画は、「テーブルスキャンかインデックス使用か」「結合方法（Nested Loop, Hash Joinなど）」などの情報を含みます。

---

### ✅ 2. 主なツール・コマンド

| DBMS       | 実行計画コマンド                             | GUIツール例           |
| ---------- | ------------------------------------ | ----------------- |
| PostgreSQL | `EXPLAIN` / `EXPLAIN ANALYZE`        | pgAdmin, DataGrip |
| MySQL      | `EXPLAIN` / `EXPLAIN FORMAT=JSON`    | MySQL Workbench   |
| Oracle     | `EXPLAIN PLAN FOR ...` / `AUTOTRACE` | SQL Developer     |
| SQL Server | 実行プランボタン or `SET SHOWPLAN_ALL`       | SSMS              |

---

### ✅ 3. 分析の手順

#### ① 実行対象SQLを特定

* アプリケーションログやスロークエリログ、APM（Datadog, NewRelicなど）で特定。

#### ② 実行計画を取得

例：PostgreSQLでの基本

```sql
EXPLAIN SELECT * FROM users WHERE email = 'example@example.com';

EXPLAIN ANALYZE SELECT * FROM users WHERE email = 'example@example.com';
```

#### ③ 実行計画を読む

| 主なキーワード                 | 説明                                     |
| ----------------------- | -------------------------------------- |
| Seq Scan（全表スキャン）        | テーブル全体を走査。基本的に遅い。                      |
| Index Scan / Index Seek | インデックスを使用して部分走査。速い。                    |
| Nested Loop             | 小さいテーブルとの結合に適している。                     |
| Hash Join / Merge Join  | 大量データのJOINに使用されるが、コスト高の場合も。            |
| Filter                  | 条件によって絞られた行数（Rows Removed by Filterなど） |

---

### ✅ 4. チューニングの実例

#### ◉ ケース1：全表スキャンをインデックス利用に改善

**Before**

```sql
EXPLAIN SELECT * FROM users WHERE email = 'a@example.com';
-- Seq Scan on users  (cost=0.00..1000.00 rows=1)
```

**原因**：

* emailカラムにインデックスがない

**対応**：

```sql
CREATE INDEX idx_users_email ON users(email);
```

**After**

```sql
-- Index Scan using idx_users_email
```

---

#### ◉ ケース2：N+1クエリによる多重アクセスの改善

**Before**

```sql
SELECT * FROM users;
→ 各ユーザーに対して
SELECT * FROM posts WHERE user_id = ?;
```

**対応**：

```sql
SELECT users.*, posts.*
FROM users
LEFT JOIN posts ON posts.user_id = users.id;
```

or ORMでeager loading指定。

---

#### ◉ ケース3：JOINパフォーマンスの改善（Hash Join → Index Seek）

**Before**

```sql
EXPLAIN ANALYZE SELECT * FROM orders JOIN customers ON orders.customer_id = customers.id;
-- Hash Join on large tables
```

**対応**：

* `orders.customer_id` や `customers.id` にインデックス追加
* 結合順序を制御（ヒント句やJOIN順）

---

### ✅ 5. コストと行数のチェック

実行計画では以下が重要です：

| 項目              | 意味                           |
| --------------- | ---------------------------- |
| **cost=**       | 実行コスト（PostgreSQL等での理論値）      |
| **rows=**       | 推定される行数。大幅にずれていると統計情報の更新が必要。 |
| **actual time** | 実際の経過時間（`EXPLAIN ANALYZE`のみ） |
| **loops=**      | 処理が繰り返された回数（Nested Loopで重要）  |

---

### ✅ 6. その他のチューニング視点

#### ● 統計情報の更新（ANALYZE）

* PostgreSQL, MySQL では `ANALYZE` コマンドで統計情報を更新し、オプティマイザの判断を正確にします。

```sql
ANALYZE users;
```

#### ● マテリアライズドビューやテンポラリテーブルの検討

* 複雑なJOINや集計を事前に計算しておき、シンプルなSELECTにする。

---

### ✅ 7. GUIツールの活用

#### ● PostgreSQL：pgAdmin, DataGrip

* EXPLAIN PLANを可視化（ツリー、グラフ）
* ステップごとの実行時間、インデックスの有無を確認

#### ● MySQL Workbench

* Visual Explain（アイコンでスキャン・JOINの種類が確認可能）

#### ● SQL Server Management Studio

* 実行プランの可視化に優れ、コストの高い箇所に色付き表示

---

### ✅ まとめ：アプリ観点の実行計画チューニングフロー

```text
1. アプリの遅いSQLを特定
   ↓
2. 実行計画を取得（EXPLAIN ANALYZEなど）
   ↓
3. 全表スキャン・JOIN方法・行数予測など確認
   ↓
4. インデックス追加 / SQL書き換え / 統計更新など実施
   ↓
5. 再度EXPLAINで改善確認
```

---

