# 🚀 データベースパフォーマンスチューニング（設計観点）


設計の観点からデータベースパフォーマンスチューニングを考える際には、「**スキーマ設計**」「**インデックス設計**」「**正規化と非正規化のバランス**」「**データ分割（パーティショニング）**」「**アーカイブ設計**」「**読み取りと書き込みの分離**」など、根本的な構造と運用方針に関わる要素が中心になります。以下、それぞれを詳しく解説します。

---

## ✅ 1. スキーマ設計の最適化

### ● カラム型の最適化

* **適切なデータ型を選ぶ**ことで、ストレージ・メモリ消費やクエリ処理効率が変わります。

  * 数値に対して`VARCHAR`を使うのはNG。
  * 文字列でも用途に応じて`CHAR`と`VARCHAR`を使い分け。

### ● NULL許容の見直し

* 不要にNULLを許容すると、インデックス効率やSQLロジックが悪化する。
* 可能であれば`NOT NULL` + 初期値設定。

### ● 一意性制約・外部キー制約の活用

* 意味のあるデータ整合性チェックにより、アプリのロジックと処理コストを減らす。

---

## ✅ 2. インデックス設計

### ● 適切なインデックスの設置

* WHERE句・JOIN・ORDER BY・GROUP BYなどで使用されるカラムに対してインデックスを設ける。
* 主キー（Primary Key）と一意キー（Unique Key）は自動でインデックスが作成される。

### ● 複合インデックスの設計

* 順序を意識しないと効果が出ない。

```sql
-- インデックス (A, B) がある場合
WHERE A = 1 AND B = 2  -- OK
WHERE B = 2            -- インデックス効かない（Aが先）
```

### ● 過剰なインデックスは避ける

* INSERT/UPDATEのパフォーマンスが悪化する。
* 定期的に使われていないインデックスを洗い出す（PostgreSQLでは`pg_stat_user_indexes`など）。

---

## ✅ 3. 正規化と非正規化のバランス

### ● 第三正規形（3NF）までは基本対応

* 冗長性排除、データ整合性確保。
* ただしJOINが頻発するようなら**非正規化**（冗長なデータ持ち）も検討。

### ● 非正規化の例

* ユーザー名や商品名など頻出データを外部キーではなく直接持つことでJOIN回避。
* 頻繁な集計に使うデータを集約テーブルとして保持（サマリーテーブル）。

---

## ✅ 4. パーティショニング（データの物理的分割）

### ● 水平パーティショニング（横分割）

* データ量が多い場合、日付・IDなどでテーブルを分割。

```sql
-- 例：ログテーブルを月単位で分割
logs_2025_06
logs_2025_07
```

### ● 垂直パーティショニング（縦分割）

* 使用頻度の高いカラムだけを分けてアクセス効率化。

---

## ✅ 5. データライフサイクルとアーカイブ戦略

### ● 古いデータをアーカイブ

* 操作対象外の過去データを別テーブルや別DBに移す。
* 本番テーブルをスリム化し、インデックス効率を維持。

---

## ✅ 6. 読み取りと書き込みの分離（スケーラビリティ設計）

### ● リードレプリカの活用（読み込み専用DB）

* 読み込みクエリを分散して負荷を軽減。
* アプリ側からのルーティング設計が必要。

---

## ✅ 7. パフォーマンス前提の設計パターン

| シナリオ     | 設計の工夫                                |
| -------- | ------------------------------------ |
| 大量ログ書き込み | パーティション + バルクインサート + アーカイブ設計         |
| 高頻度検索    | 適切なインデックス + サマリーテーブル or キャッシュ導入      |
| 頻繁なJOIN  | 非正規化 or マテリアライズドビュー活用                |
| 柔軟な検索条件  | GINインデックス（PostgreSQL）など全文検索インデックスを導入 |

---

## ✅ 8. その他の設計観点

### ● 外部キー制約の見直し

* パフォーマンスを優先し、論理的整合性だけを担保して**外部キー制約を設けない**判断もある（大規模DBの場合）。

### ● JSON/BLOB型の使用注意

* RDBMSにJSONを突っ込むと検索性やインデックス効率が落ちる。構造化が難しい場合のみ限定使用。

---

## 🔚 まとめ

| 観点        | 主な対応策                  |
| --------- | ---------------------- |
| スキーマ設計    | データ型・NULL・制約の適正化       |
| インデックス    | 使用状況に基づいた最適な設置と見直し     |
| 正規化       | 3NF準拠＋必要に応じた非正規化       |
| パーティショニング | データ量による水平・垂直分割         |
| アーカイブ     | 古いデータの隔離運用             |
| スケーリング    | 読み書き分離、分散設計            |
| 拡張設計      | サマリーテーブル、マテビュー、全文検索の活用 |

---

