# 🚀 データベースパフォーマンスチューニング（設計観点）

## ✅ 設計観点のデータベースパフォーマンスチューニング

設計の観点からデータベースパフォーマンスチューニングを考える際には、「**スキーマ設計**」「**インデックス設計**」「**正規化と非正規化のバランス**」「**データ分割（パーティショニング）**」「**アーカイブ設計**」「**読み取りと書き込みの分離**」など、根本的な構造と運用方針に関わる要素が中心になります。以下、それぞれを詳しく解説します。

---

### ✅ 1. スキーマ設計の最適化

#### ● カラム型の最適化

* **適切なデータ型を選ぶ**ことで、ストレージ・メモリ消費やクエリ処理効率が変わります。

  * 数値に対して`VARCHAR`を使うのはNG。
  * 文字列でも用途に応じて`CHAR`と`VARCHAR`を使い分け。

#### ● NULL許容の見直し

* 不要にNULLを許容すると、インデックス効率やSQLロジックが悪化する。
* 可能であれば`NOT NULL` + 初期値設定。

#### ● 一意性制約・外部キー制約の活用

* 意味のあるデータ整合性チェックにより、アプリのロジックと処理コストを減らす。

---

### ✅ 2. インデックス設計

#### ● 適切なインデックスの設置

* WHERE句・JOIN・ORDER BY・GROUP BYなどで使用されるカラムに対してインデックスを設ける。
* 主キー（Primary Key）と一意キー（Unique Key）は自動でインデックスが作成される。

#### ● 複合インデックスの設計

* 順序を意識しないと効果が出ない。

```sql
-- インデックス (A, B) がある場合
WHERE A = 1 AND B = 2  -- OK
WHERE B = 2            -- インデックス効かない（Aが先）
```

#### ● 過剰なインデックスは避ける

* INSERT/UPDATEのパフォーマンスが悪化する。
* 定期的に使われていないインデックスを洗い出す（PostgreSQLでは`pg_stat_user_indexes`など）。

---

### ✅ 3. 正規化と非正規化のバランス

#### ● 第三正規形（3NF）までは基本対応

* 冗長性排除、データ整合性確保。
* ただしJOINが頻発するようなら**非正規化**（冗長なデータ持ち）も検討。

#### ● 非正規化の例

* ユーザー名や商品名など頻出データを外部キーではなく直接持つことでJOIN回避。
* 頻繁な集計に使うデータを集約テーブルとして保持（サマリーテーブル）。

---

### ✅ 4. パーティショニング（データの物理的分割）

#### ● 水平パーティショニング（横分割）

* データ量が多い場合、日付・IDなどでテーブルを分割。

```sql
-- 例：ログテーブルを月単位で分割
logs_2025_06
logs_2025_07
```

#### ● 垂直パーティショニング（縦分割）

* 使用頻度の高いカラムだけを分けてアクセス効率化。

---

### ✅ 5. データライフサイクルとアーカイブ戦略

#### ● 古いデータをアーカイブ

* 操作対象外の過去データを別テーブルや別DBに移す。
* 本番テーブルをスリム化し、インデックス効率を維持。

---

### ✅ 6. 読み取りと書き込みの分離（スケーラビリティ設計）

#### ● リードレプリカの活用（読み込み専用DB）

* 読み込みクエリを分散して負荷を軽減。
* アプリ側からのルーティング設計が必要。

---

### ✅ 7. パフォーマンス前提の設計パターン

| シナリオ     | 設計の工夫                                |
| -------- | ------------------------------------ |
| 大量ログ書き込み | パーティション + バルクインサート + アーカイブ設計         |
| 高頻度検索    | 適切なインデックス + サマリーテーブル or キャッシュ導入      |
| 頻繁なJOIN  | 非正規化 or マテリアライズドビュー活用                |
| 柔軟な検索条件  | GINインデックス（PostgreSQL）など全文検索インデックスを導入 |

---

### ✅ 8. その他の設計観点

#### ● 外部キー制約の見直し

* パフォーマンスを優先し、論理的整合性だけを担保して**外部キー制約を設けない**判断もある（大規模DBの場合）。

#### ● JSON/BLOB型の使用注意

* RDBMSにJSONを突っ込むと検索性やインデックス効率が落ちる。構造化が難しい場合のみ限定使用。

---

### 🔚 まとめ

| 観点        | 主な対応策                  |
| --------- | ---------------------- |
| スキーマ設計    | データ型・NULL・制約の適正化       |
| インデックス    | 使用状況に基づいた最適な設置と見直し     |
| 正規化       | 3NF準拠＋必要に応じた非正規化       |
| パーティショニング | データ量による水平・垂直分割         |
| アーカイブ     | 古いデータの隔離運用             |
| スケーリング    | 読み書き分離、分散設計            |
| 拡張設計      | サマリーテーブル、マテビュー、全文検索の活用 |

---

## ✅ 更新と参照の分離

「更新と参照の分離」は、**データベースのパフォーマンス改善やシステムのスケーラビリティ向上**に非常に効果的なアプローチです。これは特に**アクセス頻度の高い読み取り処理**が多いシステム（例：ECサイト、SaaSアプリ、ニュース配信）で有効です。

---

### ✅ 1. 「更新と参照の分離」とは？

アプリケーションにおける\*\*データ更新（Write）**と**データ参照（Read）\*\*を、**物理的または論理的に別々の経路・リソースに分ける設計**です。

---

### ✅ 2. なぜ分離するのか？（課題と目的）

| 課題                        | 分離による効果                |
| ------------------------- | ---------------------- |
| 更新処理が参照とバッティングし、ロックや遅延が発生 | 読み取り用DBを分けることでロック競合を回避 |
| 読み取りアクセスが多く、DB負荷が高くなる     | 読み取り用にDBをスケールアウト可能     |
| 書き込みが頻繁で、参照の整合性が乱れる       | 非同期レプリケーション等でトラフィック分散  |
| アプリ全体のスケーラビリティが限界         | 負荷に応じて読み取り用ノードを増やせる    |

---

### ✅ 3. 実装方法：更新と参照の分離の主要パターン

#### ▶ パターン①：マスタースレーブ構成（DBレプリケーション）

* **書き込み（UPDATE/INSERT/DELETE）**：マスターDB（主系）に対して実行
* **読み取り（SELECT）**：スレーブDB（従系）に対して実行

```text
                +------------+
  Writes  --->  | Master DB  | <---+
                +------------+     |
                        |          |
                 Replication       |
                        v          |
                +------------+     |
   Reads  <---   | Slave DB   | <--+
                +------------+
```

##### ✅ 利点

* アプリコードをほとんど変えずに導入可能（接続設定の切り替えで対応）
* スレーブ数を増やすことで読み取り性能を水平方向にスケール可能

##### ⚠ 注意点

* 非同期レプリケーションのため、\*\*読み取りのデータが少し遅れる（整合性ラグ）\*\*可能性がある
* トランザクション中の読み取りにスレーブを使うと不整合が発生しやすい

---

#### ▶ パターン②：アプリ側で接続分離

アプリケーションから、

* **読み込み専用クエリ**は `read-replica` へ、
* **書き込み操作**は `primary/master` へ、

と処理を分けて接続する設計。

##### 実装例（Node.js + Sequelize）

```javascript
const sequelize = new Sequelize({
  replication: {
    read: [{ host: 'read-db', username: 'readonly', password: 'pass' }],
    write: { host: 'write-db', username: 'writeuser', password: 'pass' }
  },
  dialect: 'mysql'
});
```

---

#### ▶ パターン③：CQRS（Command Query Responsibility Segregation）

* **コマンド（Command）＝更新系操作**：状態を変更する操作（Insert, Update, Delete）
* **クエリ（Query）＝参照系操作**：状態を取得する操作（Select）

これらを**アプリケーションレベルで完全に分離**し、**別コンポーネント、別DBスキーマ、別サービス**とする。

##### 構成イメージ

```text
[更新アプリ] --Write--> [書き込みDB]
                           |
                      イベント発行
                           |
                    ↓ (同期 or 非同期)
[参照アプリ] <--Query-- [読み取りDB (整形済)]
```

##### 利点

* アプリケーションとデータベースの責務が明確に
* パフォーマンスやスキーマ設計を更新・参照それぞれに最適化できる

##### 注意点

* **データ整合性を保つためにイベント連携や非同期処理の仕組み**が必要（Kafka / RabbitMQ / DynamoDB Streamsなど）

---

### ✅ 4. 運用面の工夫とポイント

| ポイント         | 内容                               |
| ------------ | -------------------------------- |
| レプリカの整合性確認   | 遅延が大きいと古いデータを返す危険がある（秒単位～分単位）    |
| トランザクションの一貫性 | 重要なデータは書き込み直後にマスターで再読込           |
| ORMの接続制御     | ORMで「読み取り／書き込み」の接続先を切り替える機能を利用   |
| ロードバランサーの活用  | 読み取りスレーブDBの数が多い場合、分散処理のためのLBが有効  |
| モニタリング       | レプリケーションラグ、DB負荷、クエリ応答時間を常時監視すること |

---

### ✅ 5. まとめ：更新と参照の分離が有効な場面

| シナリオ                               | 効果                     |
| ---------------------------------- | ---------------------- |
| ECサイト、SNS、ポータルなどの読み取りが9割以上を占めるシステム | 読み取り性能が向上、更新とのロック競合が減少 |
| 大量のユーザーアクセスを処理したい                  | 読み取りDBのスケールアウトで対応可能    |
| 書き込み頻度は高くないが、参照はリアルタイムで欲しい         | 整合性を見極めて適切にレプリカを活用     |

---

### 🧠 補足：KVSやキャッシュとの併用

更新と参照を分離しても、**一部の「超高頻度参照」データはDBを介さずRedis等でキャッシュする**と、さらに高速化できます。

---

## ✅インデックスの設計方針

**マスターテーブル（参照用の小規模なテーブル）にもインデックスは必要です**。ただし、その**必要性はテーブルの使用方法や規模によって変わります**。

以下、マスターテーブルにインデックスが必要な理由と、その設計指針を具体的に解説します。

---

### ✅ マスターテーブルにインデックスが必要なケース

#### 1. **他テーブルとのJOINに使われる主キー・外部キー**

* JOINのたびに検索されるので、**主キーや外部キー列には必ずインデックスが必要**です。

##### 例：

```sql
-- 例：ordersテーブルとstatus_masterの結合
SELECT o.*, s.status_name
FROM orders o
JOIN status_master s ON o.status_code = s.status_code;
```

→ `status_master.status_code` にインデックスがなければ、毎回全件スキャンになります。

---

#### 2. **WHERE句でフィルタ条件として使う列**

* 「特定の区分値だけを表示」といった条件でフィルタする場合、その列にインデックスが有効です。

```sql
SELECT * FROM item_master WHERE category_code = 'ELECTRONICS';
```

→ `category_code` にインデックスがあると高速化。

---

#### 3. **頻繁に参照される中規模マスタ**

* 数千件～数万件程度のマスタでも、アプリやAPIで頻繁に参照される場合はインデックスの効果が大きくなります。

---

### ❌ インデックスが不要なケース（例外）

#### ◉ 1. 非常に小さいマスタ（例：都道府県コード、2〜3列、10件以下）

* 小さいテーブルはDBエンジンが自動で全件メモリに載せてスキャンするため、**インデックスを付けても体感上の差はほぼなし**
* オーバーヘッドを避けるために付けない選択も合理的

#### ◉ 2. SELECT対象にならず、JOINにも使われない列

* 例：備考欄（remarks）や登録者名など

---

### ✅ マスターテーブルにおけるインデックス設計の方針

| カラム種別           | インデックス必要性 | 補足                     |
| --------------- | --------- | ---------------------- |
| 主キー（PK）         | ✅ 必須      | 通常は自動でインデックスが張られる      |
| 一意キー（UK）        | ✅ 必須      | データ整合性保証にも使用           |
| 外部キーとして参照される列   | ✅ 推奨      | JOINやWHEREで使用されることが多い  |
| フィルタ条件になる区分コード等 | ✅ 推奨      | SELECTや検索条件によく使われるなら必要 |
| 備考などの低頻度参照列     | ❌ 不要      | 更新時のオーバーヘッドを避ける        |

---

### ✅ 補足：読み取りキャッシュとの併用も有効

* マスターデータは内容がほぼ変わらないため、**アプリケーションやRedisなどにキャッシュ**すると、インデックスアクセスすら不要になる場合もあります。

---

### ✅ まとめ：マスターテーブルのインデックス設計指針

| 項目                    | 判定基準                  |
| --------------------- | --------------------- |
| 他テーブルから参照されるか？        | YES → インデックス必要        |
| WHERE句・JOINで頻繁に使われるか？ | YES → インデックス必要        |
| データ件数が100件未満か？        | YES → インデックス効果は限定的    |
| アプリから何度もアクセスされるか？     | YES → パフォーマンス向上のため検討  |
| 更新頻度が高いか？             | YES → インデックス数は最小限にすべき |

---

## ✅ PostgreSQL / MySQL / Oracle / Aurora各DB製品の設計方針

PostgreSQL、MySQL、Oracle、Amazon Aurora はいずれもリレーショナルデータベースですが、それぞれ特性や推奨設計方針に違いがあります。ここでは**パフォーマンスチューニングや拡張性を意識した設計観点**から、4つのDB製品の設計方針を比較・整理して説明します。

---

### ✅ 1. PostgreSQL の設計方針

#### 特徴：

* 標準SQLへの準拠度が高い
* 拡張性・カスタマイズ性が非常に高い
* GIN/GiSTなど強力な全文検索インデックス
* JSONBやArray型など、非構造データの取り扱いに強い

#### 設計指針：

| 項目          | 設計方針                                                |
| ----------- | --------------------------------------------------- |
| インデックス      | B-tree以外に、GIN/GiSTを活用（例：全文検索、JSONB検索）               |
| データ型        | JSONB・Array・UUIDなど高度な型を活用可                          |
| トランザクション    | MVCCにより読み書き競合に強いが、Vacuumを意識した設計が必要                  |
| パーティショニング   | `Declarative Partitioning`（宣言的分割）を使う：`PARTITION BY` |
| マテリアライズドビュー | サマリーテーブルの代替として強力（REFRESH可）                          |
| 拡張機能        | PostGIS（地理空間）やpg\_partman（パーティション管理）などを用途別に導入可      |

---

### ✅ 2. MySQL（InnoDB） の設計方針

#### 特徴：

* 軽量・高速で、Webアプリと相性が良い
* デフォルトストレージエンジンは InnoDB（トランザクション対応）
* Oracleと比べるとシンプルで導入しやすい
* JSON型対応はするが、PostgreSQLに比べて制限がある

#### 設計指針：

| 項目        | 設計方針                                             |
| --------- | ------------------------------------------------ |
| インデックス    | 覆いインデックス（Covering Index）設計が特に有効                  |
| パーティショニング | `PARTITION BY` は存在するが制限が多く、現実的には**アプリ側で分割運用**が多い |
| 外部キー      | InnoDBでは使用可能。複雑すぎる制約は避けるべき（パフォーマンス低下）            |
| レプリケーション  | マスター-スレーブ型（Auroraより古典的）。リードレプリカを設計段階で考慮          |
| JSONデータ   | JSON型ありだが、インデックス制限あり。構造化データに留意すべき                |
| マテビュー     | 標準では未サポート（別テーブル＋定期更新で代替）                         |

---

### ✅ 3. Oracle Database の設計方針

#### 特徴：

* 商用DBの中で機能・安定性が非常に高い
* エンタープライズ用途（基幹系、金融系など）に強い
* PL/SQLによるロジック組み込み
* パーティショニング・圧縮・管理機能が非常に充実

#### 設計指針：

| 項目        | 設計方針                                        |
| --------- | ------------------------------------------- |
| パーティショニング | 範囲・リスト・ハッシュなど複数方式が選択可能。大規模設計で必須             |
| インデックス    | ビットマップインデックス、関数ベースインデックスなど用途ごとに最適化可能        |
| サマリーテーブル  | マテリアライズドビューあり（QUERY REWRITE対応可）             |
| ストレージ最適化  | 表圧縮・セグメントアドバイザなどを活用                         |
| 論理設計      | ER図に加え、業務ロジックをDB内（PL/SQL）に持つ設計が多い           |
| パフォーマンス設計 | Oracle Optimizerヒントを明示的に使いSQLチューニングを行う文化が強い |

---

### ✅ 4. Amazon Aurora（PostgreSQL/MySQL互換） の設計方針

#### 特徴：

* クラウドネイティブなRDBMS（AWSマネージド）
* Aurora専用の高速ストレージを使用
* 自動フェイルオーバー・自動バックアップ・リードレプリカが容易
* PostgreSQL/MySQL互換モードあり（構文/制約は基本準拠）

#### 設計指針：

| 項目       | 設計方針                                                        |
| -------- | ----------------------------------------------------------- |
| スケーラビリティ | **リードレプリカを前提とした読み込み分離設計**が重要                                |
| フェイルオーバー | Aurora Cluster を構成し、**フェイルオーバー対象を明確に設計**する（Writer/Reader分離） |
| ストレージ    | 自動スケーリングのため、設計上の容量制限は緩和（ただしクエリ効率設計は依然重要）                    |
| キャッシュ    | Auroraクエリキャッシュ＋アプリ層でのElastiCacheの組み合わせが有効                   |
| データ圧縮    | Aurora内部で最適化されるが、**不要なカラムや肥大化JSONは避ける**                     |
| モニタリング   | CloudWatch＋Performance Insightsを前提に、設計段階でKPIを意識した構成が望ましい    |

---

### 🔚 製品別まとめ比較表

| 観点 \ DB     | PostgreSQL | MySQL     | Oracle   | Aurora                |
| ----------- | ---------- | --------- | -------- | --------------------- |
| 正規SQL準拠     | ◎          | ○         | ◎        | ○（互換）                 |
| JSON対応      | ◎（JSONB）   | △         | △        | ○（互換）                 |
| パーティショニング   | ◎（宣言的）     | △（制限あり）   | ◎（多彩）    | △（PostgreSQL互換でも制限あり） |
| マテビュー       | ○          | ✕         | ◎        | PostgreSQL互換で○        |
| トランザクション性能  | ◎          | ○         | ◎        | ◎                     |
| クラスタリング/冗長化 | 外部で設計      | マスター-スレーブ | RAC等で高可用 | Aurora Cluster 標準提供   |
| 拡張性         | ◎（拡張モジュール） | △         | △        | ◎（スケールアウトしやすい）        |

---

