# 🚀 データベースパフォーマンスチューニング（設計観点）


設計の観点からデータベースパフォーマンスチューニングを考える際には、「**スキーマ設計**」「**インデックス設計**」「**正規化と非正規化のバランス**」「**データ分割（パーティショニング）**」「**アーカイブ設計**」「**読み取りと書き込みの分離**」など、根本的な構造と運用方針に関わる要素が中心になります。以下、それぞれを詳しく解説します。

---

## ✅ 1. スキーマ設計の最適化

### ● カラム型の最適化

* **適切なデータ型を選ぶ**ことで、ストレージ・メモリ消費やクエリ処理効率が変わります。

  * 数値に対して`VARCHAR`を使うのはNG。
  * 文字列でも用途に応じて`CHAR`と`VARCHAR`を使い分け。

### ● NULL許容の見直し

* 不要にNULLを許容すると、インデックス効率やSQLロジックが悪化する。
* 可能であれば`NOT NULL` + 初期値設定。

### ● 一意性制約・外部キー制約の活用

* 意味のあるデータ整合性チェックにより、アプリのロジックと処理コストを減らす。

---

## ✅ 2. インデックス設計

### ● 適切なインデックスの設置

* WHERE句・JOIN・ORDER BY・GROUP BYなどで使用されるカラムに対してインデックスを設ける。
* 主キー（Primary Key）と一意キー（Unique Key）は自動でインデックスが作成される。

### ● 複合インデックスの設計

* 順序を意識しないと効果が出ない。

```sql
-- インデックス (A, B) がある場合
WHERE A = 1 AND B = 2  -- OK
WHERE B = 2            -- インデックス効かない（Aが先）
```

### ● 過剰なインデックスは避ける

* INSERT/UPDATEのパフォーマンスが悪化する。
* 定期的に使われていないインデックスを洗い出す（PostgreSQLでは`pg_stat_user_indexes`など）。

---

## ✅ 3. 正規化と非正規化のバランス

### ● 第三正規形（3NF）までは基本対応

* 冗長性排除、データ整合性確保。
* ただしJOINが頻発するようなら**非正規化**（冗長なデータ持ち）も検討。

### ● 非正規化の例

* ユーザー名や商品名など頻出データを外部キーではなく直接持つことでJOIN回避。
* 頻繁な集計に使うデータを集約テーブルとして保持（サマリーテーブル）。

---

## ✅ 4. パーティショニング（データの物理的分割）

### ● 水平パーティショニング（横分割）

* データ量が多い場合、日付・IDなどでテーブルを分割。

```sql
-- 例：ログテーブルを月単位で分割
logs_2025_06
logs_2025_07
```

### ● 垂直パーティショニング（縦分割）

* 使用頻度の高いカラムだけを分けてアクセス効率化。

---

## ✅ 5. データライフサイクルとアーカイブ戦略

### ● 古いデータをアーカイブ

* 操作対象外の過去データを別テーブルや別DBに移す。
* 本番テーブルをスリム化し、インデックス効率を維持。

---

## ✅ 6. 読み取りと書き込みの分離（スケーラビリティ設計）

### ● リードレプリカの活用（読み込み専用DB）

* 読み込みクエリを分散して負荷を軽減。
* アプリ側からのルーティング設計が必要。

---

## ✅ 7. パフォーマンス前提の設計パターン

| シナリオ     | 設計の工夫                                |
| -------- | ------------------------------------ |
| 大量ログ書き込み | パーティション + バルクインサート + アーカイブ設計         |
| 高頻度検索    | 適切なインデックス + サマリーテーブル or キャッシュ導入      |
| 頻繁なJOIN  | 非正規化 or マテリアライズドビュー活用                |
| 柔軟な検索条件  | GINインデックス（PostgreSQL）など全文検索インデックスを導入 |

---

## ✅ 8. その他の設計観点

### ● 外部キー制約の見直し

* パフォーマンスを優先し、論理的整合性だけを担保して**外部キー制約を設けない**判断もある（大規模DBの場合）。

### ● JSON/BLOB型の使用注意

* RDBMSにJSONを突っ込むと検索性やインデックス効率が落ちる。構造化が難しい場合のみ限定使用。

---

## 🔚 まとめ

| 観点        | 主な対応策                  |
| --------- | ---------------------- |
| スキーマ設計    | データ型・NULL・制約の適正化       |
| インデックス    | 使用状況に基づいた最適な設置と見直し     |
| 正規化       | 3NF準拠＋必要に応じた非正規化       |
| パーティショニング | データ量による水平・垂直分割         |
| アーカイブ     | 古いデータの隔離運用             |
| スケーリング    | 読み書き分離、分散設計            |
| 拡張設計      | サマリーテーブル、マテビュー、全文検索の活用 |

---

## ✅ PostgreSQL / MySQL / Oracle / Aurora各DB製品の設計方針

PostgreSQL、MySQL、Oracle、Amazon Aurora はいずれもリレーショナルデータベースですが、それぞれ特性や推奨設計方針に違いがあります。ここでは**パフォーマンスチューニングや拡張性を意識した設計観点**から、4つのDB製品の設計方針を比較・整理して説明します。

---

### ✅ 1. PostgreSQL の設計方針

#### 特徴：

* 標準SQLへの準拠度が高い
* 拡張性・カスタマイズ性が非常に高い
* GIN/GiSTなど強力な全文検索インデックス
* JSONBやArray型など、非構造データの取り扱いに強い

#### 設計指針：

| 項目          | 設計方針                                                |
| ----------- | --------------------------------------------------- |
| インデックス      | B-tree以外に、GIN/GiSTを活用（例：全文検索、JSONB検索）               |
| データ型        | JSONB・Array・UUIDなど高度な型を活用可                          |
| トランザクション    | MVCCにより読み書き競合に強いが、Vacuumを意識した設計が必要                  |
| パーティショニング   | `Declarative Partitioning`（宣言的分割）を使う：`PARTITION BY` |
| マテリアライズドビュー | サマリーテーブルの代替として強力（REFRESH可）                          |
| 拡張機能        | PostGIS（地理空間）やpg\_partman（パーティション管理）などを用途別に導入可      |

---

### ✅ 2. MySQL（InnoDB） の設計方針

#### 特徴：

* 軽量・高速で、Webアプリと相性が良い
* デフォルトストレージエンジンは InnoDB（トランザクション対応）
* Oracleと比べるとシンプルで導入しやすい
* JSON型対応はするが、PostgreSQLに比べて制限がある

#### 設計指針：

| 項目        | 設計方針                                             |
| --------- | ------------------------------------------------ |
| インデックス    | 覆いインデックス（Covering Index）設計が特に有効                  |
| パーティショニング | `PARTITION BY` は存在するが制限が多く、現実的には**アプリ側で分割運用**が多い |
| 外部キー      | InnoDBでは使用可能。複雑すぎる制約は避けるべき（パフォーマンス低下）            |
| レプリケーション  | マスター-スレーブ型（Auroraより古典的）。リードレプリカを設計段階で考慮          |
| JSONデータ   | JSON型ありだが、インデックス制限あり。構造化データに留意すべき                |
| マテビュー     | 標準では未サポート（別テーブル＋定期更新で代替）                         |

---

### ✅ 3. Oracle Database の設計方針

#### 特徴：

* 商用DBの中で機能・安定性が非常に高い
* エンタープライズ用途（基幹系、金融系など）に強い
* PL/SQLによるロジック組み込み
* パーティショニング・圧縮・管理機能が非常に充実

#### 設計指針：

| 項目        | 設計方針                                        |
| --------- | ------------------------------------------- |
| パーティショニング | 範囲・リスト・ハッシュなど複数方式が選択可能。大規模設計で必須             |
| インデックス    | ビットマップインデックス、関数ベースインデックスなど用途ごとに最適化可能        |
| サマリーテーブル  | マテリアライズドビューあり（QUERY REWRITE対応可）             |
| ストレージ最適化  | 表圧縮・セグメントアドバイザなどを活用                         |
| 論理設計      | ER図に加え、業務ロジックをDB内（PL/SQL）に持つ設計が多い           |
| パフォーマンス設計 | Oracle Optimizerヒントを明示的に使いSQLチューニングを行う文化が強い |

---

### ✅ 4. Amazon Aurora（PostgreSQL/MySQL互換） の設計方針

#### 特徴：

* クラウドネイティブなRDBMS（AWSマネージド）
* Aurora専用の高速ストレージを使用
* 自動フェイルオーバー・自動バックアップ・リードレプリカが容易
* PostgreSQL/MySQL互換モードあり（構文/制約は基本準拠）

#### 設計指針：

| 項目       | 設計方針                                                        |
| -------- | ----------------------------------------------------------- |
| スケーラビリティ | **リードレプリカを前提とした読み込み分離設計**が重要                                |
| フェイルオーバー | Aurora Cluster を構成し、**フェイルオーバー対象を明確に設計**する（Writer/Reader分離） |
| ストレージ    | 自動スケーリングのため、設計上の容量制限は緩和（ただしクエリ効率設計は依然重要）                    |
| キャッシュ    | Auroraクエリキャッシュ＋アプリ層でのElastiCacheの組み合わせが有効                   |
| データ圧縮    | Aurora内部で最適化されるが、**不要なカラムや肥大化JSONは避ける**                     |
| モニタリング   | CloudWatch＋Performance Insightsを前提に、設計段階でKPIを意識した構成が望ましい    |

---

### 🔚 製品別まとめ比較表

| 観点 \ DB     | PostgreSQL | MySQL     | Oracle   | Aurora                |
| ----------- | ---------- | --------- | -------- | --------------------- |
| 正規SQL準拠     | ◎          | ○         | ◎        | ○（互換）                 |
| JSON対応      | ◎（JSONB）   | △         | △        | ○（互換）                 |
| パーティショニング   | ◎（宣言的）     | △（制限あり）   | ◎（多彩）    | △（PostgreSQL互換でも制限あり） |
| マテビュー       | ○          | ✕         | ◎        | PostgreSQL互換で○        |
| トランザクション性能  | ◎          | ○         | ◎        | ◎                     |
| クラスタリング/冗長化 | 外部で設計      | マスター-スレーブ | RAC等で高可用 | Aurora Cluster 標準提供   |
| 拡張性         | ◎（拡張モジュール） | △         | △        | ◎（スケールアウトしやすい）        |

---

