# マイクロサービスアーキテクチャ

## 開発アプローチ

マイクロサービスアーキテクチャにおける開発アプローチは、組織の規模、チーム構造、技術スタック、ビジネス要件によって最適な方法が異なります。以下に、それぞれのアプローチの特徴と選択基準を整理します。

---

### **1. マイクロサービス単位で独立して開発する場合**
#### **特徴**
- **独立性が高い**: 各サービスが独自のコードベース、CI/CDパイプライン、デプロイサイクルを持つ。
- **技術的多様性**: サービスごとに異なる技術スタック（言語、フレームワーク、DB）を選択可能。
- **チーム自治**: 各チームがサービスの設計から運用までを完全にオーナーシップを持つ（「You build it, you run it」モデル）。

#### **メリット**
- **スケーラビリティ**: チーム/サービスの追加が容易。
- **変更の分離**: 一つのサービスの変更が他に影響しない。
- **高速な開発サイクル**: サービス単位で独立してリリース可能。

#### **デメリット**
- **運用オーバーヘッド**: 複数のリポジトリ、CI/CD、監視システムが必要。
- **統合テストの難しさ**: サービス間の連携テストが複雑化。
- **技術的負債**: 技術スタックが分散すると標準化が困難になる可能性。

#### **適するケース**
- 大規模な組織で複数の機能チームが並行開発する場合。
- サービスのライフサイクルが明確に分離されている場合（例：決済サービスと注文サービス）。

---

### **2. 単一プロジェクト（モノリポ）で管理する場合**
#### **特徴**
- **単一リポジトリ（Monorepo）**: 複数のマイクロサービスを一つのプロジェクトで管理。
- **共有ツールチェーン**: 統一的なビルド、テスト、デプロイフロー。
- **コード共有**: 共通ライブラリや設定を簡単に共有可能。

#### **メリット**
- **開発効率**: コードの一貫性や依存関係管理が容易。
- **クロスサービス変更**: 複数サービスにまたがる変更を原子性（atomic）で実施可能。
- **学習コスト低減**: 統一的な技術スタックで新人教育が容易。

#### **デメリット**
- **結合度の上昇**: サービス間の境界が曖昧になるリスク。
- **ビルド時間の増加**: プロジェクト規模が大きくなるとCI/CDが遅延する可能性。
- **スケーリング制約**: チーム数が増えると競合が発生しやすくなる。

#### **適するケース**
- 小～中規模チームで、サービス間の連携が密な場合。
- 初期段階で迅速なプロトタイピングが必要な場合。

---

### **選択基準**
| **判断要素**               | **独立リポジトリ** | **Monorepo** |
|---------------------------|-------------------|-------------|
| チーム規模                | 大規模            | 小～中規模  |
| デプロイ頻度              | 高頻度・独立      | 低～中頻度  |
| 技術的多様性の必要性      | 高い              | 低い        |
| クロスサービス変更の多さ  | 少ない            | 多い        |
| インフラ管理リソース      | 豊富              | 限定的      |

---

### **ハイブリッドアプローチ**
- **サブグループ単位のMonorepo**: 関連性の高いサービス群（例：注文関連サービス）ごとにMonorepoを分ける。
- **ツールの活用**: Bazel, Nx, Lernaなどで大規模Monorepoを効率化。

---

### **ベストプラクティス**
1. **初期段階ではMonorepoを検討**: プロトタイピングやサービス境界が不明確な場合。
2. **明確な境界（Bounded Context）が定義できたら分離**: ドメイン駆動設計（DDD）を適用。
3. **統一インターフェース**: API契約（OpenAPI/Swagger）やイベントスキーマ（Avro/Protobuf）で標準化。

マイクロサービスの成功には、**「技術的な分離」と「組織的な協調」のバランス**が不可欠です。プロジェクトの成熟度に応じて柔軟にアプローチを選択することが必要です。

---

## マイクロサービス単位で独立する場合共通機能の開発

マイクロサービス単位で独立して開発する場合、共通機能（認証、ロギング、監視、クライアントライブラリなど）の扱いは重要な設計課題です。適切に管理しないと、重複実装や技術的負債の原因になります。以下に具体的なアプローチを解説します。

---

### **1. 共通機能の分類と対応策**
#### **(1) 横断的関心事（Cross-Cutting Concerns）**
- **例**: 認証/認可、ロギング、メトリクス収集、分散トレーシング、リトライ/サーキットブレーカー
- **解決策**:
  - **サイドカー/プロキシパターン**: 
    - Service Mesh（Istio, Linkerd）を導入し、通信層で共通処理をオフロード。
    - 例: IstioでJWT検証やメトリクス収集を集中管理。
  - **APIゲートウェイ**:
    - Kong, Apigeeなどで認証/レート制限を一元化。

#### **(2) ビジネスロジック共通化**
- **例**: 顧客情報検索、商品マスタデータ取得
- **解決策**:
  - **専用マイクロサービス化**:
    - 共通機能を独立したサービス（例: `User-Service`, `Product-Service`）として提供。
    - 他サービスはAPIコールまたはイベント購読で利用。
  - **注意点**:
    - 共通サービスがボトルネックにならないよう、キャッシュ（Redis）や非同期通信（Kafka）を活用。

#### **(3) クライアントライブラリ**
- **例**: サービス間通信用SDK、エラーハンドリングライブラリ
- **解決策**:
  - **内部ライブラリ化**:
    - 言語別にパッケージ管理（NuGet, Maven, npm）で共有。
    - バージョン互換性維持のため、**セマンティックバージョニング**を厳守。
  - **自動生成**:
    - OpenAPI仕様からクライアントコードを自動生成（Swagger Codegen, OpenAPI Generator）。

---

### **2. 実装パターン詳細**
#### **パターンA: サービスメッシュ活用**
```mermaid
graph LR
  A[Service A] -->|mTLS+Trace| Istio
  B[Service B] -->|mTLS+Trace| Istio
  Istio -->|認証/監視| Prometheus
```

#### **パターンB: 共通ライブラリ管理**
```
monorepo/
├── libs/
│   ├── auth/  # 認証ライブラリ
│   ├── logging/ # 構造化ロギング
│   └── api-client/ # サービス間通信SDK
├── services/
│   ├── order-service/
│   └── payment-service/
```

#### **パターンC: バックエンドフォーサービス（BFF）**
- フロントエンド向け共通処理をBFF層に集約。

---

### **3. 避けるべきアンチパターン**
- **密結合な共通モジュール**:
  - サービス間でデータベースを直接共有（→ 代わりにAPIで公開）。
- **過度なライブラリ依存**:
  - ライブラリ更新時に全サービスで一斉変更が必要にならないよう、インターフェースは最小限に。
- **共通サービスの単一障害点化**:
  - 認証サービスがダウンすると全サービス影響を受ける（→ キャッシュ/フォールバック機構必須）。

---

### **4. 組織的なプラクティス**
- **共通機能チームの設立**:
  - プラットフォームエンジニアリングチームが基盤機能を開発・メンテナンス。
- **契約テスト（Contract Testing）**:
  - Pactなどで共通インターフェースの互換性を保証。
- **ドキュメント標準化**:
  - 共通機能の利用方法を集中管理（内部Portal, Swagger Hub）。

---

### **5. 技術選定例**
| 機能            | 推奨技術                                                                 |
|-----------------|--------------------------------------------------------------------------|
| 認証/認可       | Keycloak, Amazon Cognito + サービスメッシュ                              |
| 監視            | Prometheus + Grafana（メトリクス）, ELK（ログ）, Jaeger（トレーシング）  |
| サービス間通信  | gRPC（高性能）, AsyncAPI（イベント駆動）                                 |
| 設定管理        | HashiCorp Consul, AWS AppConfig                                          |

---

### **トレードオフの考慮**
- **独立性 vs 効率性**:
  - 共通化しすぎるとマイクロサービスの自律性が損なわれる。
- **早期最適化の回避**:
  - プロジェクト初期は重複実装を許容し、パターンが明確化した段階で共通化。

GoogleやNetflixは「**共通化が必要だと3回以上実装された時**」をルールにしています。まずはドメイン境界を明確にし、本当に共通化すべき機能かを見極めることが重要です。
